
-----------------------------------------------------------------
## Python
Python console 
-- REPL  REPL stands for Read-Eval-Print Loop. It's an interactive programming environment that reads input from the user, evaluates it, and then prints the result back to the user. Python comes with its own REPL, called the Python interpreter or the Python shell.  

-- IDLE
to exit --- exit()


-----------------------------------------------------------------
###  pep8 recommendations


Here are some of the key recommendations from PEP 8:

Naming Conventions: Use lowercase for variables, UPPERCASE for constants, CamelCase for class names, and snake_case for function names.

Indentation: Use 4 spaces for indentation, and never use tabs.

Whitespace: Use a single space after commas, colons, and semicolons, but no space before them. Use a single space before and after binary operators.

Comments: Use comments to explain the "why" behind your code, not the "what." Write clear and descriptive comments that explain the intent of the code.

Line Length: Limit lines to a maximum of 79 characters.

Imports: Import modules at the top of the file, and group them in the following order: standard library modules, third-party modules, and your own modules.

Blank Lines: Use blank lines to separate logical sections of your code, but don't use them excessively.

Whitespace in Expressions and Statements: Use a single space around assignment operators (=), comparisons (==, <, >, <=, >=, !=, in, not in, is, is not), and arithmetic operators (+, -, *, /, //, %, **).

Documentation Strings (Docstrings): Use triple quotes for multi-line docstrings, and single quotes for single-line docstrings.

Function and Method Arguments: Put a space after the comma in function and method arguments.

Class Definitions: Put a single space after the colon in class definitions.

File Encoding: Use UTF-8 as the default file encoding.

Magic Comments: Use magic comments (# type: ignore) sparingly, and only when necessary.

Exceptions: Use a single space after the except keyword.

Return Statements: Put a space after the return keyword.

Whitespace Around Keywords: Put a single space after keywords like if, elif, else, for, while, except, finally, and with.

Trailing Whitespace: Avoid trailing whitespace at the end of lines.

PEP 8 is not a strict set of rules, and it's not mandatory to follow it. However, adhering to PEP 8 can make your code more readable and maintainable, and it can help you avoid common pitfalls and bugs.

-----------------------------------------------------------------
###  pip

pip is a package manager for Python that allows you to install and manage Python packages. It is the standard package manager for Python and is used to install packages from the Python Package Index (PyPI) or from other sources.

in cmd --->
pip install package-name  
pip uninstall package-name  
pip list  
pip search package-name  
pip show package-name  
pip install --upgrade package-name  
pip install -r requirements.txt  
pip freeze > requirements.txt  
pip install package-name==version  

update pip  
python.exe -m pip install --upgrade pip

-----------------------------------------------------------------
### comments
single line  --- #  
multi --- '''

escape sequence char -- backslash
\"  

```python
print("Hi",2,3,4) # Hi 2 3 4 
print("Hi",2,3,4,sep="#") # Hi#2#3#4 
print("Hi",2,3,4," ",sep="#",end="bye") #Hi#2#3#4# bye  
```

-----------------------------------------------------------------
### python automaticaly assigns datatype
get type -- type(<name>)  
complex(1,2) -- for complex numbers  
in Python all is an objects  

-----------------------------------------------------------------
### list types  
[] -- for list  
() -- tuple -- immutable list  
{} -- dictionary1 = {"key1" : value1, "key2" : value2, "key3" : value3,}  

-----------------------------------------------------------------
### floor division //
```python
print(22/7) # 3.142857142857143
print(22//7) # 3 -- floored value

# exponential **
print(3**3) #27 

```

-----------------------------------------------------------------
### type casting 
```python
int()
str()
float()
bool()
list()
tuple()
set()
dict()
```

-----------------------------------------------------------------
### Get input from the screen
To get user input

```python
input() #always takes as string 
```

-----------------------------------------------------------------
### String 1

stings are imutable 
if saying str.upper() -- it creates a new string 
  
```python

name = "John Doe"
print(f"My name is {name}.")  # Output: "My name is John Doe."

word = "Hello World"
print(len(word)) # Output: 11
print(word[6]) # Output: W
print(word[0:5]) # Output: Hello
print(word[:5]) # Output: Hello
print(word[:]) # Output: Hello World
print(word[0:-3]) # print(word[0:len(word)-3]) # Output: Hello Wo
print(word[-3:-1])  # Output: rl
print(word[-1:-3]) # RHS>LHS # incorrect will print nothing # Output: print nothing
```

f-string --> are placeholders that will be replaced by the actual values of key and value during string formatting.  
This allows you to easily insert variables and expressions into strings without needing to use string concatenation or the .format() method.

-----------------------------------------------------------------
### String 2
  
  
```python

str.rstrip("!") #removes all char ! from the end
str.capitalize() #first letter as capital
str.split(" ") #splits with space and returns list
str.count("Hi") #retruns count of all occurence Hi in string 

string.endswith(suffix[, start[, end]])
string = "Hello, World!"
print(string.endswith("World!"))  # Output: True
print(string.endswith("world!"))  # Output: False (case-sensitive)
print(string.endswith("World", 0, 5))  # Output: False (search only in the first 5 characters)

string.find("is") #returns index of first occurence of is else -1

string.index("is") #throws error if is not found 
string.isalpha()
string.isalnum()
string.islower()
string.isupper()
string.isspace() #checks whitespaces 
string.swapcase()
string.title() # changes first letter of all words in uppercase

```

-----------------------------------------------------------------
### Datetime
  
  
```python
from datetime import datetime

# Create a datetime object representing the current date and time
now = datetime.now()

# Format the date and time using strftime()
formatted_date = now.strftime("%Y-%m-%d %H:%M:%S")
print(formatted_date)  # Output: "2022-02-28 13:45:00"

```

-----------------------------------------------------------------
### If Else
  
```python
x = 10

if x > 5:
    print("x is greater than 5")
elif x < 5:
    print("x is less than 5")
else:
    print("x is equal to 5")



#result = value_if_true if condition else value_if_false

x = 10
result = "Even" if x % 2 == 0 else "Odd"
print(result)  # Output: Even

x = 10
y = 20
result = (x + y) if x > y else (x - y)
print(result)  # Output: -10


```

-----------------------------------------------------------------
### Match case -- Python doesn't have a built-in switch statement  
available in py>3.10  
here break is not required 
  
```python
parameter = "Geeksforgeeks"

match parameter:

	case first : 
		do_something(first)
	
	case second : 
		do_something(second)
		
	case third : 
		do_something(third)
		.............
		............
	case n :
		do_something(n)
	case _ :  # Default
		nothing_matched_function()
		
```
-----------------------------------------------------------------
### comparison operators  

is: The is operator compares the identity of two objects, meaning it checks if the two objects refer to the same memory location. It returns True if the objects are the same, and False otherwise. 
  
==: The == operator compares the values of two objects, meaning it checks if the values of the two objects are the same. It returns True if the values are the same, and False otherwise.

```python
a = [1, 2, 3]
b = [1, 2, 3]
c = a

print(a is b)  # Output: False
print(a is c)  # Output: True

print(a == b)  # Output: True

```

-----------------------------------------------------------------
### Enum
  
  
```python

import enum

class Color(enum.Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

print(Color.RED)    # Output: Color.RED
print(Color.RED.value)  # Output: 1

#You can also use the auto() function from the enum module to automatically assign unique integer values to the members:

import enum

class Color(enum.Enum):
    RED = enum.auto()
    GREEN = enum.auto()
    BLUE = enum.auto()

print(Color.RED)    # Output: Color.RED
print(Color.RED.value)  # Output: 1

#Enumerations can also have string values:
import enum

class Color(enum.Enum):
    RED = 'red'
    GREEN = 'green'
    BLUE = 'blue'

print(Color.RED)    # Output: Color.RED
print(Color.RED.value)  # Output: 'red'


print(Color.RED == Color.RED)    # Output: True
print(Color.RED == Color.GREEN)  # Output: False
print(Color.RED is Color.RED)    # Output: True
print(Color.RED is Color.GREEN)  # Output: False

```

-----------------------------------------------------------------
### For
  
  
```python
# Define a tuple of names
names = ("John Doe", "Jane Doe", "Alice Smith", "Bob Johnson")

# Iterate over the tuple of names and print each name
for name in names:
    print(name)

for i in range(1,100):
    print(i)


# Iterate over a range of numbers from 0 to 10 with a step size of 2
for i in range(0, 11, 2):
    print(i)

```

-----------------------------------------------------------------
### While
    
```python
i = 0

while i < 5:
    print(i)
    i += 1

```
Python doesn't have a built-in do-while loop  

-----------------------------------------------------------------
### Break Continue
  
```python
for i in range(5):
    if i == 3:
        break #breaks the loop and will not exe further 
    print(i)

0
1
2

for i in range(5):
    if i == 3:   #skips the Iteration and will not print 3 but doesn't break 
        continue
    print(i)

0
1
2
4

```

-----------------------------------------------------------------
### Function
    
```python

# ex 1
def add_numbers(a, b):
    return a + b

result = add_numbers(5, 3)
print(result)  # Output: 8

# ex 2 defaults
def avg_digit(a=4,b=6):
    return (a + b)/2

print(avg_digit()) # take defaults for a and b
print(avg_digit(20)) # take defaults for b
print(avg_digit(b=30)) # take defaults for a
print(avg_digit(b=30, a=30)) # order does not matter if added parama name
print(avg_digit(20,30))

# ex 3 dictionary
def avg_sal(d):
    sum = 0 
    for key, value in d.items():
        sum = sum + value 
    print("Average is: " , sum/len(d))


my_dict = {'ram': 10000, 'shayam': 30000, 'mohan': 50000}
avg_sal(my_dict)


# ex 4 list as *

def avg_digit(*nums):
    print(type(nums)) # it will consider passed num list as tuple 
    sum = 0 
    for i in nums:
        sum = sum + i 

    print("Average is: " , sum/len(nums))

avg_digit(2,4,5,6)
list1 = [2,4,6,8,4,6]
avg_digit(*list1 ) # passing list 


# ex 5 dict as **

def avg_sal(**d):
    sum = 0 
    for key, value in d.items():
         print(f'{key}: {value}')
         sum = sum + value 
    print("Average is: " , sum/len(d))

my_dict = {'ram': 10000, 'shayam': 30000, 'mohan': 50000}
avg_sal(**my_dict)

```

the * and ** operators are used for unpacking iterables and dictionaries, respectively. They can be used in function calls to unpack arguments or keyword arguments.  

-----------------------------------------------------------------
### Range
  
  In Python, range() is a built-in function that generates a sequence of numbers. It is commonly used in for loops to iterate over a sequence of numbers. The range() function can take one, two, or three arguments:  
  
One argument: range(stop)

This creates a sequence from 0 up to (but not including) stop.
Example: range(5) generates a sequence from 0 to 4.
Two arguments: range(start, stop)

This creates a sequence from start up to (but not including) stop.
Example: range(2, 5) generates a sequence from 2 to 4.
Three arguments: range(start, stop, step)

This creates a sequence from start up to (but not including) stop, with a step size of step.
Example: range(1, 10, 2) generates a sequence from 1 to 9, with a step size of 2.
  
```python
for i in range(5):
    print(i)

for i in range(2, 5):
    print(i)

for i in range(1, 10, 2):
    print(i)

numbers = list(range(5))
print(numbers)

for i in range(10, 0, -1):
    print(i)

```

-----------------------------------------------------------------
### List
  
  
```python

empty_list = []
print(empty_list)

numbers = [1, 2, 3, 4, 5]
print(numbers)

fruits = ["apple", "banana", "cherry"]
print(fruits)

mixed_list = [1, "apple", 3.14, True]
print(mixed_list)


nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(nested_list)

number_range = list(range(1, 6))
print(number_range)

squares = [x**2 for x in range(1, 6)] # list comprehension 
print(squares)
# output [1, 4, 9, 16, 25]

```

-----------------------------------------------------------------
### List comprehensions
  
  list comprehensions provide a concise way to create lists. They are a syntactic construct that allows you to create a list based on existing lists, iterables, or other data structures.  
[expression for item in iterable if condition]
  
```python

# Using a for loop
squares1 = []
for i in range(10):
    squares1.append(i**2)
    
print(squares1)

# Using a list comprehension
squares2 = [i**2 for i in range(10)]
print(squares2)

#[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# Using a for loop
even_squares1 = []
for i in range(10):
    if i % 2 == 0:
        even_squares1.append(i**2)
print(even_squares1)

# Using a list comprehension
even_squares2 = [i**2 for i in range(10) if i % 2 == 0]
print(even_squares2)

#[0, 4, 16, 36, 64]

# nested list 
# Using a for loop
pairs1 = []
for x in range(3):
    for y in range(3):
        pairs1.append((x, y))
print(pairs1)

# Using a list comprehension
pairs2 = [(x, y) for x in range(3) for y in range(3)]
print(pairs2)

#[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]

```

-----------------------------------------------------------------
### List Methods
  
  
```python

my_list = [1, 2, 3, 4, 5]
print(my_list[0])  # Output: 1

my_list[0] = 9
print(my_list)  # Output: [9, 2, 3, 4, 5]

my_list.append(6)
print(my_list)  # Output: [9, 2, 3, 4, 5, 6]

my_list.insert(2, 7)
print(my_list)  # Output: [9, 2, 7, 3, 4, 5, 6]

my_list.remove(7)
print(my_list)  # Output: [9, 2, 3, 4, 5, 6]

popped_item = my_list.pop()
print(popped_item)  # Output: 6
print(my_list)  # Output: [9, 2, 3, 4, 5]

# # Example 1: Removing and returning the last element
# my_list = [1, 2, 3, 4, 5]
# last_element = my_list.pop()
# print(last_element)  # Output: 5
# print(my_list)  # Output: [1, 2, 3, 4]

# # Example 2: Removing and returning the first element
# first_element = my_list.pop(0)
# print(first_element)  # Output: 1
# print(my_list)  # Output: [2, 3, 4]

# # Example 3: Removing and returning an element at a specific index
# third_element = my_list.pop(1)
# print(third_element)  # Output: 3
# print(my_list)  # Output: [2, 4]


sliced_list = my_list[1:4]
print(sliced_list)  # Output: [2, 3, 4]

my_list.reverse()
print(my_list)  # Output: [5, 4, 3, 2, 9]

my_list.sort()
print(my_list)  # Output: [2, 3, 4, 5, 9]

squared_numbers = [x**2 for x in range(1, 6)]
print(squared_numbers)  # Output: [1, 4, 9, 16, 25]

copied_list = my_list.copy()
print(copied_list)  # Output: [2, 3, 4, 5, 9]

print(7 in my_list)  # Output: False

another_list = [7, 8, 9]
concatenated_list = my_list + another_list
print(concatenated_list)  # Output: [2, 3, 4, 5, 9, 7, 8, 9]

print(my_list.count(3))  # Output: 1

print(len(my_list))  # Output: 5

my_list.clear()
print(my_list)  # Output: []



```
.pop() method in Python is a list method that removes and returns the last element from the list.  
It modifies the original list in place. If you specify an index, it will remove and return the element at that index.  
If you do not specify an index, it will remove and return the last element in the list.

-----------------------------------------------------------------
### Two List Methods
  
  
```python

# Define two lists
list1 = [1, 2, 3, 4, 5]
list2 = [4, 5, 6, 7, 8]

# Appending list1 to list2
list2.extend(list1)
print(list2)  # Output: [4, 5, 6, 7, 8, 1, 2, 3, 4, 5]

# Removing duplicates from the combined list
list2 = list(set(list2))
print(list2)  # Output: [1, 2, 3, 4, 5, 6, 7, 8]

# Sorting the combined list in descending order
list2.sort(reverse=True)
print(list2)  # Output: [8, 7, 6, 5, 4, 3, 2, 1]

#Union of two lists (combining unique elements from both lists):

list1 = [1, 2, 3]
list2 = [3, 4, 5]

union_list = list(set(list1) | set(list2))
print(union_list)  # Output: [1, 2, 3, 4, 5]

#Difference between two lists (elements that are in list1 but not in list2):
list1 = [1, 2, 3, 4, 5]
list2 = [3, 4, 5, 6, 7]

difference_list = list(set(list1) - set(list2))
print(difference_list)  # Output: [1, 2]

#Symmetric difference between two lists (elements that are in either list1 or list2, but not in both):
list1 = [1, 2, 3, 4, 5]
list2 = [3, 4, 5, 6, 7]

symmetric_difference_list = list(set(list1) ^ set(list2))
print(symmetric_difference_list)  # Output: [1, 2, 6, 7]

#Concatenating two lists (combining elements from both lists):
list1 = [1, 2, 3]
list2 = [4, 5, 6]

concatenated_list = list1 + list2
print(concatenated_list)  # Output: [1, 2, 3, 4, 5, 6]

#Merging two lists (combining elements from both lists without duplicates):
list1 = [1, 2, 3]
list2 = [3, 4, 5]

merged_list = list(set(list1) | set(list2))
print(merged_list)  # Output: [1, 2, 3, 4, 5]

#Intersection of two lists (elements that are common in both lists):
list1 = [1, 2, 3]
list2 = [3, 4, 5]

intersection_list = list(set(list1) & set(list2))
print(intersection_list)  # Output: [3]

#Checking if all elements of one list are present in another list:
list1 = [1, 2, 3]
list2 = [1, 2, 3, 4, 5]

is_subset = all(elem in list2 for elem in list1)
print(is_subset)  # Output: True


```

-----------------------------------------------------------------
### Tuples 
A tuple is an immutable data type, meaning that once it is created, its elements cannot be changed or modified. Tuples are similar to lists, but they are enclosed in parentheses () instead of square brackets [].  
In Python, a tuple is a collection of elements, which can be of any data type, including characters. A tuple can contain duplicate elements, including duplicate characters.
Tuples can contain elements of different types, and they can be indexed and sliced in the same way as lists. 

```python
#Creating a Tuple with One Element:

my_tuple = (1,) #single ele tuple -- add , in the last otherwise considered as int 

single_element_tuple = tuple([1])
print(single_element_tuple)  # Output: (1,)

multiple_elements_tuple = tuple([1, 2, 3])
print(multiple_elements_tuple)  # Output: (1, 2, 3)

my_tuple = ('a', 'b', 'c', 'a', 'd', 'e', 'a')
print(my_tuple.count('a'))  # Output: 3


my_tuple = (1, 2, 3, 4, 5)

#Repeating a Tuple:
repeated_tuple = my_tuple * 2
print(repeated_tuple)  # Output: (1, 2, 3, 4, 5, 1, 2, 3, 4, 5)

#Unpacking a Tuple:
a, b, c, d, e = my_tuple
print(a, b, c, d, e)  # Output: 1 2 3 4 5

#Converting a List to a Tuple:
my_list = [1, 2, 3, 4, 5]
tuple_from_list = tuple(my_list)
print(tuple_from_list)  # Output: (1, 2, 3, 4, 5)

#Checking if Two Tuples are Equal:
tuple1 = (1, 2, 3)
tuple2 = (1, 2, 3)
print(tuple1 == tuple2)  # Output: True

#Converting a List of Tuples to a Dictionary:
list_of_tuples = [(1, 'a'), (2, 'b'), (3, 'c')]
dictionary_from_list = dict(list_of_tuples)
print(dictionary_from_list)  # Output: {1: 'a', 2: 'b', 3: 'c'}


#Counting the Occurrences of an Element in a Tuple:
my_tuple = (1, 2, 3, 4, 5, 3, 3)
count_of_3 = my_tuple.count(3)
print(count_of_3)  # Output: 3

#Reversing a Tuple:
my_tuple = (1, 2, 3, 4, 5)
reversed_tuple = my_tuple[::-1]
print(reversed_tuple)  # Output: (5, 4, 3, 2, 1)

#Sorting a Tuple:
my_tuple = (4, 2, 1, 3, 5)
sorted_tuple = tuple(sorted(my_tuple))
print(sorted_tuple)  # Output: (1, 2, 3, 4, 5)

#Checking if a Tuple is Empty:
empty_tuple = ()
is_empty = not bool(empty_tuple)
print(is_empty)  # Output: True


#Splitting Tuples:
my_tuple = (1, 2, 3, 4, 5, 6)
split_tuple1 = my_tuple[:3]
split_tuple2 = my_tuple[3:]
print(split_tuple1)  # Output: (1, 2, 3)
print(split_tuple2)  # Output: (4, 5, 6)

#Checking if Two Tuples Overlap:
tuple1 = (1, 2, 3, 4)
tuple2 = (3, 4, 5, 6)
overlap = bool(set(tuple1) & set(tuple2))
print(overlap)  # Output: True

#Creating a Tuple with Named Elements Using NamedTuple:
from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
point = Point(1, 2)
print(point.x, point.y)  # Output: 1 2

#Creating a Tuple from a String:
string = "hello"
tuple_from_string = tuple(string)
print(tuple_from_string)  # Output: ('h', 'e', 'l', 'l', 'o')

#Checking if a Tuple Contains Only Unique Elements:
unique_tuple = (1, 2, 3, 4, 5)
is_unique = len(unique_tuple) == len(set(unique_tuple))
print(is_unique)  # Output: True


```

-----------------------------------------------------------------
### Swapping Values Between Variables Using Tuples:
  
```python
a = 1
b = 2
a, b = b, a
print(a, b)  # Output: 2 1

```

-----------------------------------------------------------------
### Build-in methods
  
  
```python

Tuples have many built-in functions and methods that are similar to those of lists in Python. Here are some common functions and methods that can be used with tuples:

len(): Returns the number of elements in the tuple.

tuple(): Converts a sequence into a tuple.

sorted(): Returns a new sorted list of the elements in the tuple.

max(): Returns the largest element in the tuple.

min(): Returns the smallest element in the tuple.

sum(): Returns the sum of all elements in the tuple.

count(): Returns the number of occurrences of a specified value in the tuple.

index(): Returns the index of the first occurrence of a specified value in the tuple.

+: Concatenates two tuples and returns a new tuple.

*: Repeats the elements of the tuple a specified number of times and returns a new tuple.

in: Checks if a specified value is present in the tuple.

not in: Checks if a specified value is not present in the tuple.

==: Compares two tuples for equality.

!=: Compares two tuples for inequality.

<: Checks if the first tuple is less than the second tuple.

<=: Checks if the first tuple is less than or equal to the second tuple.

>: Checks if the first tuple is greater than the second tuple.

>=: Checks if the first tuple is greater than or equal to the second tuple.

del: Deletes the entire tuple.

enumerate(): Returns an enumerate object that contains tuples of the index and value of each element in the tuple.

filter(): Returns an iterator that contains the elements from the tuple for which the specified function returns True.

map(): Returns an iterator that contains the results of applying the specified function to each element in the tuple.

reversed(): Returns a reverse iterator that contains the elements of the tuple in reverse order.

slice(): Returns a slice object that represents the specified range of elements in the tuple.

sorted(): Returns a new sorted list of the elements in the tuple.

zip(): Returns an iterator that combines the elements of the tuple with the elements of one or more other iterables.

```

-----------------------------------------------------------------
### Docstrings 
  
In Python, a docstring is a string literal that is used to document a function, method, class, or module. It is placed as the first statement in the body of the function, method, class, or module, and is enclosed in triple quotes (''' or """). Docstrings are used to provide documentation about the purpose, usage, and behavior of the code, and can be accessed using the .__doc__ attribute of the object.
  
```python

def add(a, b):
    '''This function takes two numbers as input and returns their sum.'''
    return a + b

print(add.__doc__)

#docstring for a class:
class Point:
    '''This class represents a point in 2D space.'''
    def __init__(self, x, y):
        '''Constructor for the Point class.'''
        self.x = x
        self.y = y

```

-----------------------------------------------------------------
### Recursion 
  
  
```python

def fact(n):
    if n==0 or n==1:
        return 1
    else:
        return n * fact(n-1)
    
print(fact(5))


def fibbo(n):
    if n <= 1:
        return n
    else:
        return fibbo(n - 1) + fibbo(n - 2)

fi = fibbo(10)
print(fi)


```

-----------------------------------------------------------------
### Sets 
  
In Python, a set is an *unordered* collection of unique elements. Sets are mutable, which means that you can add or remove elements from a set after it has been created. Sets are implemented using a hash table, which allows for fast lookup and insertion of elements.

```python

# Create an empty set
empty_set = set()

# Create a set with elements
my_set = {1, 2, 3, 4, 5}

# Add elements to a set
my_set.add(6)
my_set.add(7)

# Remove an element from a set
my_set.remove(3)


set1 = {1, 2, 3}
set2 = {1, 2, 3, 4, 5}
print(set1.issubset(set2))  # Output: True

set1 = {1, 2, 3, 4, 5}
set2 = {1, 2, 3}
print(set1.issuperset(set2))  # Output: True


#isdisjoint() Method: Returns True if the two sets have no common elements, otherwise False.
set1 = {1, 2, 3}
set2 = {4, 5, 6}
print(set1.isdisjoint(set2))  # Output: True

#difference() Method: Returns a new set with elements that are in the original set but not in the specified set.
set1 = {1, 2, 3}
set2 = {3, 4, 5}
difference_set = set1.difference(set2)
print(difference_set)  # Output: {1, 2}


# Create two sets
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

# Union of sets
union = set1.union(set2)  # Output: {1, 2, 3, 4, 5, 6, 7, 8}

# Intersection of sets
intersection = set1.intersection(set2)  # Output: {4, 5}

# Difference of sets
difference = set1.difference(set2)  # Output: {1, 2, 3}

# Symmetric difference of sets
symmetric_difference = set1.symmetric_difference(set2)  # Output: {1, 2, 3, 6, 7, 8}




```
isdisjoint() Method: Returns True if the two sets have no common elements, otherwise False.  

pop() Method: Removes and returns an arbitrary element from the set. If the set is empty, it raises a KeyError.

remove() Method: Removes the specified element from the set. If the element is not present, it raises a KeyError.

discard() Method: Removes the specified element from the set if it is present. If the element is not present, it doesn't raise an error.

-----------------------------------------------------------------
### Sets update
  
The union() method in Python is used to return a new set containing all the unique elements from both the sets. It creates a new set by combining the elements of the two sets without any repetitions.

The update() method in Python is used to modify a set by adding all the elements from another set or any other iterable object like a list, tuple, or string.

```python

# Create two sets
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

# Union of sets
union_set = set1.union(set2)
print(union_set)  # Output: {1, 2, 3, 4, 5, 6, 7, 8}


# Create a set
my_set = {1, 2, 3, 4, 5}

# Update the set by adding elements from another set
my_set.update({6, 7, 8})
print(my_set)  # Output: {1, 2, 3, 4, 5, 6, 7, 8}

# Update the set by adding elements from a list
my_set.update([9, 10])
print(my_set)  # Output: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

# Update the set by adding elements from a tuple
my_set.update((11, 12))
print(my_set)  # Output: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}

# Update the set by adding characters from a string
my_set.update("hello")
print(my_set)  # Output: {'h', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'l', 'o', 'e'}


set1 = {1, 2, 3}
set2 = {3, 4, 5}
symmetric_difference_set = set1.symmetric_difference(set2)
print(symmetric_difference_set)  # Output: {1, 2, 4, 5}



set1 = {1, 2, 3}
set2 = {3, 4, 5}
set1.update(set2)
print(set1)  # Output: {1, 2, 3, 4, 5}


set1 = {1, 2, 3}
set2 = {3, 4, 5}
set1.difference_update(set2)
print(set1)  # Output: {1, 2}


set1 = {1, 2, 3}
set2 = {3, 4, 5}
set1.intersection_update(set2)
print(set1)  # Output: {3}


set1 = {1, 2, 3}
set2 = {3, 4, 5}
set1.symmetric_difference_update(set2)
print(set1)  # Output: {1, 2, 4, 5}


```
symmetric_difference() Method: Returns a new set with elements that are in either the original set or the specified set, but not in both.  
update() Method: Adds all elements from another set (or any other iterable object) to the original set.  
difference_update() Method: Removes all elements from the original set that are also present in the specified set.  
intersection_update() Method: Removes all elements from the original set that are not present in both sets.  
symmetric_difference_update() Method: Modifies the original set to contain elements that are in either the original set or the specified set, but not in both.  

-----------------------------------------------------------------
### del
  
The del keyword in Python is used to delete objects. It can be used to delete elements from lists, elements from dictionaries, attributes from objects, and objects themselves.

```python

my_list = [1, 2, 3, 4, 5]
del my_list[2]  # Deletes the element at index 2
print(my_list)  # Output: [1, 2, 4, 5]

del my_list  # Deletes the object
print(my_list)  # Output: NameError: name 'my_list' is not defined


class MyClass:
    def __init__(self, x):
        self.x = x

obj = MyClass(5)
del obj.x  # Deletes the attribute 'x' from the object
print(obj.x)  # Raises AttributeError: 'MyClass' object has no attribute 'x'


```

-----------------------------------------------------------------
### Dictionaries
  
 dictionary in Python is a data structure that is used to store data in a key-value pair format. Each key in the dictionary must be unique and immutable (such as a string, number, or tuple), and each key is associated with a value. The value can be of any data type, including another dictionary.
 
```python
# Creating a dictionary
my_dict = {
    "name": "John",
    "age": 30,
    "city": "New York"
}

# Accessing values in the dictionary
print(my_dict["name"])  # Output: John
print(my_dict["age"])   # Output: 30
print(my_dict["city"])  # Output: New York

# Adding a new key-value pair to the dictionary
my_dict["country"] = "USA"
print(my_dict["country"])  # Output: USA

# Removing a key-value pair from the dictionary
del my_dict["city"]
print(my_dict)  # Output: {'name': 'John', 'age': 30, 'country': 'USA'}

print(my_dict.get("city"))  # Output: None
print(my_dict["city"])  # Output: Will throw Error

```

-----------------------------------------------------------------
### Dictionary methods
  
  
```python

#clear(): Removes all items from the dictionary.
my_dict = {"name": "John", "age": 30}
my_dict.clear()
print(my_dict)  # Output: {}

#copy(): Returns a shallow copy of the dictionary.
my_dict = {"name": "John", "age": 30}
new_dict = my_dict.copy()
print(new_dict)  # Output: {'name': 'John', 'age': 30}

#get(key[, default]): Returns the value for the specified key. If the key is not found, it returns the default value (which is None by default).
my_dict = {"name": "John", "age": 30}
print(my_dict.get("name"))    # Output: John
print(my_dict.get("country")) # Output: None
print(my_dict.get("country", "USA")) # Output: USA

#items(): Returns a view object that displays a list of a dictionary's key-value pairs as tuples.
my_dict = {"name": "John", "age": 30}
print(my_dict.items()) # Output: dict_items([('name', 'John'), ('age', 30)])

#keys(): Returns a view object that displays a list of a dictionary's keys.
my_dict = {"name": "John", "age": 30}
print(my_dict.keys()) # Output: dict_keys(['name', 'age'])

#values(): Returns a view object that displays a list of a dictionary's values.
my_dict = {"name": "John", "age": 30}
print(my_dict.values()) # Output: dict_values(['John', 30])

#pop(key[, default]): Removes and returns the item with the specified key. If the key is not found, it returns the default value (which is None by default).
my_dict = {"name": "John", "age": 30}
print(my_dict.pop("name"))    # Output: John
print(my_dict.pop("country")) # Output: KeyError: 'country'
print(my_dict.pop("country", "USA")) # Output: USA

#popitem(): Removes and returns an arbitrary (key, value) pair from the dictionary.
my_dict = {"name": "John", "age": 30}
print(my_dict.popitem()) # Output: ('age', 30)
print(my_dict) # Output: {'name': 'John'}

#setdefault(key[, default]): Returns the value of the specified key. If the key does not exist, it inserts the key with the specified default value (which is None by default) and returns the default value.
my_dict = {"name": "John", "age": 30}
print(my_dict.setdefault("name")) # Output: John
print(my_dict.setdefault("country")) # Output: None
print(my_dict) # Output: {'name': 'John', 'age': 30, 'country': None}

#update(iterable): Updates the dictionary with the key-value pairs from the specified iterable.
my_dict = {"name": "John", "age": 30}
my_dict.update({"country": "USA"})
print(my_dict) # Output: {'name': 'John', 'age': 30, 'country': 'USA'}

#fromkeys(iterable[, value]): Returns a new dictionary with keys from the iterable and values set to the specified value (which is None by default).
keys = ["name", "age", "country"]
my_dict = dict.fromkeys(keys)
print(my_dict) # Output: {'name': None, 'age': None, 'country': None}

#len(): Returns the number of items in the dictionary.
my_dict = {"name": "John", "age": 30}
print(len(my_dict)) # Output: 2

```

-----------------------------------------------------------------
### Loop with else
  
In Python, you can use an else block in a for or while loop. The else block is executed when the loop completes normally (without encountering a break statement). 

```python
for i in range(5):
    print(i)
else:
    print("Loop completed normally")

i = 0
while i < 5:
    print(i)
    i += 1
else:
    print("Loop completed normally")


#output
0
1
2
3
4
Loop completed normally



```

-----------------------------------------------------------------
### Exception handling
  
Exception handling in Python is a way to deal with errors or exceptional situations that might occur during the execution of a program. Python provides a try-except-else-finally block for handling exceptions.


```python
try:
    # Code that might raise an exception
    x = 1 / 0
except ZeroDivisionError:
    # Code that handles the exception
    print("Cannot divide by zero")
else:
    # Code that runs if no exception occurs
    print("Division successful")
finally:
    # Code that always runs, regardless of whether an exception occurred
    print("Finally block")

# #Output
# Cannot divide by zero
# Finally block

# You can also use try-except blocks to catch exceptions and then raise a new exception:

try:
    # Code that might raise an exception
    x = 1 / 0
except ZeroDivisionError as e:
    # Code that handles the ZeroDivisionError exception
    print("Cannot divide by zero")
    raise ValueError("Error occurred") from e

# #Output
# Cannot divide by zero
# Traceback (most recent call last):
  # File "<stdin>", line 2, in <module>
# ValueError: Error occurred


#example of a stack trace:
def function_a():
    function_b()

def function_b():
    function_c()

def function_c():
    x = 1 / 0

try:
    function_a()
except ZeroDivisionError as e:
    print(f"An error occurred: {e}")

# #Output
# An error occurred: division by zero
# Traceback (most recent call last):
  # File "<stdin>", line 11, in <module>
  # File "<stdin>", line 2, in function_a
  # File "<stdin>", line 5, in function_b
  # File "<stdin>", line 8, in function_c
# ZeroDivisionError: division by zero

```
### Exception Types in Python

- **Exception**: The base class for all built-in exceptions. It is the parent class for all exceptions in Python.

- **TypeError**: Raised when an operation or function is applied to an object of an inappropriate type.

- **ValueError**: Raised when a built-in operation or function receives an argument that has the right type but an inappropriate value.

- **ZeroDivisionError**: Raised when the second argument of a division or modulo operation is zero.

- **FileNotFoundError**: Raised when a file or directory is requested but cannot be found.

- **IndexError**: Raised when a sequence subscript is out of range.

- **KeyError**: Raised when a dictionary key is not found.

-----------------------------------------------------------------
### Enumerate Function 
  

In Python, the enumerate() function is used to loop over a sequence (such as a list, tuple, or string) while keeping track of the index of each element. It returns an enumerate object, which is an iterator that yields pairs of an index and the corresponding element.

```python

#enumerate(iterable, start=0)

my_list = ['apple', 'banana', 'cherry']
for index, value in enumerate(my_list):
    print(f"Index: {index}, Value: {value}")

# Index: 0, Value: apple
# Index: 1, Value: banana
# Index: 2, Value: cherry

my_list = ['apple', 'banana', 'cherry']
for index, value in enumerate(my_list, start = 1):
    print(f"Index: {index}, Value: {value}")

# It will start index from 1 
# Index: 1, Value: apple
# Index: 2, Value: banana
# Index: 3, Value: cherry
```

-----------------------------------------------------------------
### Virtual Environment in Python --TODO
  
A virtual environment in Python is a self-contained directory that contains a Python installation for a particular version of Python, plus a number of additional packages. This allows you to work on multiple projects with different dependencies without them interfering with each other.
  
A virtual environment in Python is a self-contained directory that contains a Python installation for a particular version of Python, plus a number of additional packages. This allows you to work on multiple projects with different dependencies without them interfering with each other.

Here's how to create and use a virtual environment in Python:

1. **Creating a Virtual Environment**:
    - Open a terminal or command prompt.
    - Navigate to the directory where you want to create the virtual environment.
    - Run the following command to create a virtual environment named `venv`:

        ```
        python -m venv venv
        ```

    - This will create a directory named `venv` in the current directory with a Python installation and a `pip` package manager.

2. **Activating the Virtual Environment**:
    - To activate the virtual environment, run the following command:

        - On Windows:

            ```
            venv\Scripts\activate
            ```

        - On macOS and Linux:

            ```
            source venv/bin/activate
            ```

    - When the virtual environment is activated, your terminal or command prompt prompt will change to indicate that the virtual environment is active.

3. **Using the Virtual Environment**:
    - When the virtual environment is active, any Python commands you run will use the Python installation and packages in the virtual environment.
    - For example, you can install packages using `pip`:

        ```
        pip install package_name
        ```

4. **Deactivating the Virtual Environment**:
    - To deactivate the virtual environment and return to the global Python installation, run the following command:

        ```
        deactivate
        ```

    - After deactivating the virtual environment, your terminal or command prompt prompt will return to its normal state.

5. **Deleting the Virtual Environment**:
    - To delete the virtual environment, simply delete the directory where it is located.

This is a basic overview of virtual environments in Python. They are a powerful tool for managing dependencies and isolating project environments. You can find more information in the [Python documentation](https://docs.python.org/3/library/venv.html).


-----------------------------------------------------------------
### import
  
  
```python

import my_module
my_module.my_function()    

from my_module import my_function
my_function()    

import my_module as mm
mm.my_function()    

#Importing All Attributes from a Module:
from my_module import * 
my_function()   

#Importing a Package:
import my_package
my_package.my_module.my_function()     	


import math
print(dir(math))
print(dir(math.__doc__.__add__))


```

-----------------------------------------------------------------
### if __name__ == "__main__":
  
In Python, the '__name__' variable is a special built-in variable. When a Python script is executed, __name__ is automatically set to "__main__" if the script is the main program being run. If the script is being imported as a module, then __name__ is set to the name of the module.

The if '__name__' == "__main__": construct is often used to create a script that can be both run as a standalone program and imported as a module into another program.

if you are importing the module having methods valls in other module it is required to add this statement to avoid exe of those methods 
```python
#py_math.py
import math as mm

def sqrt(i):
    return mm.sqrt(i)

def justprint():
    print("u r in math.py")

PI = 3.14 

justprint()

#main.py
import py_math
#from py_math import * 

#justprint()
py_math.justprint()

#if u run > python main.py -- it will print 2 times 
# u r in math.py
# u r in math.py

# even adding import py_math -- will call justprint()

```

-----------------------------------------------------------------
### import os  --TODO
  
  For Dir and file operations
  
  os.system(cmd) #to run apps
```python



```
-----------------------------------------------------------------
### Shutil Module --TODO
  
The shutil module in Python is used for high-level file operations, such as copying, moving, and deleting files and directories. It provides several functions for working with files and directories in a more powerful and efficient way than the built-in os module.

Here are some of the commonly used functions in the shutil module:

Here are some of the commonly used functions in the `shutil` module:

- `shutil.copy(src, dst)`: Copies the file `src` to the file or directory `dst`. The destination `dst` can be a directory or a filename. If `dst` is a directory, the file will be copied into that directory with the same filename.

- `shutil.move(src, dst)`: Moves the file or directory `src` to the location `dst`. This is similar to the `mv` command in Unix.

- `shutil.copytree(src, dst)`: Recursively copies the directory `src` and its contents to the directory `dst`.

- `shutil.rmtree(path)`: Recursively deletes the directory `path` and all its contents.

- `shutil.make_archive(base_name, format, root_dir)`: Creates an archive file (such as a zip or tar file) from the directory `root_dir` and stores it with the name `base_name`.

- `shutil.unpack_archive(filename, extract_dir)`: Extracts the contents of the archive file `filename` into the directory `extract_dir`.



```python

import shutil

# Copy file
shutil.copy('source.txt', 'destination.txt')

# Move file
shutil.move('source.txt', 'destination.txt')

# Copy directory
shutil.copytree('source_directory', 'destination_directory')

# Move directory
shutil.move('source_directory', 'destination_directory')

# Remove directory
shutil.rmtree('directory_to_remove')

# Create a zip file
shutil.make_archive('archive', 'zip', 'directory_to_archive')

# Extract a zip file
shutil.unpack_archive('archive.zip', 'extracted_directory')


```
-----------------------------------------------------------------
### global
  
  Declaring a variable as global in Python means that the variable will be treated as a global variable within the current module or scope. This means that changes made to the variable in one part of the code will be reflected in other parts of the code as well.
  
```python

py = "This is a global variable"

def my_function():
    global py
    py = "This is a modified global variable"

my_function()
print(py)  # Output: This is a modified global variable

```

-----------------------------------------------------------------
### File Handling 
  
File can't be read in write mode. 
'w' write 
'r' read mode is default  
'rb' read binary

```python
f = open('Sample.txt', 'r')

txt = f.read()
print(txt)
f.close()

#f = open('Sample.txt', 'w') #this write mode will create new file if file is not present

# write 
# Open the file in write mode
with open("Sample.txt", "w") as file:
    # Write content to the file
    file.write("This is a new line of text.\n")
    file.write("This is another line of text.\n")

# Read the file content to verify
with open("Sample.txt", "r") as file:
    file_content = file.read()

# Print the content
print(file_content)

#readlines(): This method reads the entire content of the file and returns a list of strings, where each string is a line from the file.
with open("file.txt", "r") as file:
    lines = file.readlines()
for line in lines:
    print(line.strip())

# Create a list of strings
lines = ["This is line 1.\n", "This is line 2.\n", "This is line 3.\n"]

# Open the file in write mode
with open("file.txt", "w") as file:
    # Write the list of strings to the file
    file.writelines(lines)

# Read the file content to verify
with open("file.txt", "r") as file:
    file_content = file.read()

# Print the content
print(file_content)

with open("file.txt", "r") as file:
    # Move the cursor to the beginning of the file
    file.seek(0)
    # Read the first 10 characters from the file
    content = file.read(10)
    print(content)

with open("file.txt", "r") as file:
    # Read the first 10 characters from the file
    content = file.read(10)
    # Print the current file cursor position
    print(file.tell())

```  

seek(): This function is used to change the file cursor position. It takes two arguments: offset and whence. The offset argument specifies the number of bytes to move the cursor, and the whence argument specifies the reference point for the cursor movement. The whence argument can take one of the following values:

0: The beginning of the file  
1: The current file cursor position (default)  
2: The end of the file  

tell(): This function returns the **current file cursor position** as an integer number of bytes from the beginning of the file.

flush(): This method flushes the internal buffer of the file object, forcing all buffered data to be written to the file.  

close(): This method closes the file object. Once a file is closed, no further read or write operations can be performed on it.

-----------------------------------------------------------------
### truncate()
  
In Python, the truncate() method is used to resize a file to a specified size. It is a method of the file object returned by the open() function when the file is opened in write or read/write mode ("w", "r+", "a", or "a+"). The truncate() method takes an optional size argument that specifies the new size of the file in bytes. If the size argument is omitted or negative, the file is truncated to the current file cursor position.

```python

# Open the file in write mode
with open("file.txt", "w") as file:
    # Write some content to the file
    file.write("This is a line of text.\n")
    file.write("This is another line of text.\n")

# Open the file in read/write mode
with open("file.txt", "r+") as file:
    # Move the cursor to the beginning of the file
    file.seek(0)
    # Read the first line from the file
    content = file.readline()
    # Print the content
    print(content)
    # Truncate the file to the current file cursor position
    file.truncate()
    # Read the first line from the file again
    content = file.readline()
    # Print the content
    print(content)

```

In this example, the file file.txt is opened in write mode, and two lines of text are written to the file. The file is then opened in read/write mode, and the cursor is moved to the beginning of the file. The first line of the file is read and printed, and then the file is truncated to the current file cursor position. This means that the file is resized to the beginning of the file, and all content after the cursor position is removed. Finally, the first line of the file is read and printed again to show that the file has been truncated.

-----------------------------------------------------------------
### Lambda functions
  
 A lambda function in Python is a small anonymous function that can take any number of arguments, but can only have one expression. Lambda functions are often used when you need a simple function for a short period of time. They are defined using the lambda keyword, followed by a comma-separated list of arguments, a colon ( : ), and the expression to be evaluated.
 
 fun_name = lambda (params : action)
 
```python
# Define a lambda function that adds two numbers
add = lambda x, y: x + y

# Call the lambda function with two arguments
result = add(3, 5)
print(result)  # Output: 8
```

passing lambda in function 

```python
# Define a custom function that takes a lambda function as an argument
def apply_function(numbers, func):
    return [func(x) for x in numbers]

# Define a list of numbers
numbers = [1, 2, 3, 4, 5]

# Use a lambda function to square each number
squared_numbers = apply_function(numbers, lambda x: x ** 2)
print(squared_numbers)  # Output: [1, 4, 9, 16, 25]

```

-----------------------------------------------------------------
### Map, Filter and Reduce 
  
In Python, map(), filter(), and reduce() are built-in functions that are commonly used for functional programming tasks. They are often used in conjunction with lambda functions to perform operations on sequences like lists, tuples, and sets.  

Note that in Python 3.x, map() and filter() return iterators instead of lists. You can convert these iterators to lists by wrapping them in a list() function call.  

map(): The map() function takes a function and an iterable (like a list) as arguments and applies the function to each element of the iterable, returning a new iterable with the results.

```python
numbers = [1, 2, 3, 4, 5]
doubled_numbers = map(lambda x: x * 2, numbers)
print(list(doubled_numbers))  # Output: [2, 4, 6, 8, 10]

```

filter(): The filter() function takes a function and an iterable as arguments and applies the function to each element of the iterable, returning a new iterable with only the elements for which the function returns True.

```python

numbers = [1, 2, 3, 4, 5]
even_numbers = filter(lambda x: x % 2 == 0, numbers)
print(list(even_numbers))  # Output: [2, 4]

```

reduce(): The reduce() function is used to apply a function to a sequence of elements and reduce the sequence to a single value. It is part of the functools module in Python 3.x and needs to be imported.

```python
from functools import reduce
numbers = [1, 2, 3, 4, 5]
sum_of_numbers = reduce(lambda x, y: x + y, numbers)
print(sum_of_numbers)  # Output: 15

```
-----------------------------------------------------------------
### Walrus Operator 
  
The Walrus operator (:=) in Python, also known as the "assignment expression," allows you to assign a value to a variable as part of an expression. This can be useful in situations where you want to assign a value to a variable and use that value in the same expression.

Added in > py 3.8

```python

# Without using the walrus operator
x = 10
if x > 5:
    print(x)  # Output: 10

# Using the walrus operator
if (x := 10) > 5:
    print(x)  # Output: 10

# List comprehension without the walrus operator
squares = [x * x for x in range(10) if x % 2 == 0]

# List comprehension with the walrus operator
squares = [y * y for x in range(10) if (y := x * x) % 2 == 0]

# While loop without the walrus operator
x = 0
while x < 10:
    print(x)
    x += 1

# While loop with the walrus operator
x = 0
while (y := x * x) < 10:
    print(y)
    x += 1

```

-----------------------------------------------------------------
### Requests Module in Python
  
The requests module in Python is a popular library for making HTTP requests. It simplifies the process of making HTTP requests and handling HTTP responses, making it easier to work with APIs and web services.

pip install requests

in case of Error Could not install packages due to an OSError:

pip install --upgrade pip
pip install --upgrade setuptools

pip install charset-normalizer

check python version, exe path 

to change --
Open VS Code: Start by opening Visual Studio Code.

Open the Command Palette: Press Ctrl+Shift+P (Windows/Linux) or Cmd+Shift+P (macOS) to open the command palette.

Select the Python Interpreter: Type "Python: Select Interpreter" in the command palette and select the command from the list that appears. This command allows you to choose the Python interpreter you want to use for your workspace.

C:/Users/admin/AppData/Local/Microsoft/WindowsApps/python3.11.exe
C:/Python312/python.exe

```python

| Verb     | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| GET      | The default method for submitting form data. It appends the form data to the URL in the form of query parameters. This method is typically used for retrieving data from a server.                                                                                                                                                                                                                                                                                             |
| POST     | This method submits the form data in the body of the HTTP request. It is used for submitting sensitive or large amounts of data, such as login credentials or file uploads.                                                                                                                                                                                                                                                                                                    |
| PUT      | This method is used to send data to the server to create or update a resource. It is commonly used in RESTful APIs.                                                                                                                                                                                                                                                                                                                                                                 |
| DELETE   | This method is used to delete a resource on the server. It is also commonly used in RESTful APIs.                                                                                                                                                                                                                                                                                                                                                                                   |
| PATCH    | This method is used to partially update a resource on the server. It is commonly used in RESTful APIs.                                                                                                                                                                                                                                                                                                                                                                             |
| HEAD     | This method is similar to `GET`, but it only retrieves the headers of the response, not the body. It is commonly used for checking the status of a resource.                                                                                                                                                                                                                                                                                                                     |
| OPTIONS  | This method is used to retrieve the options for a resource. It is commonly used in RESTful APIs.                                                                                                                                                                                                                                                                                                                                                                                    |
| TRACE    | This method is used to trace the route of a request. It is rarely used in practice.                                                                                                                                                                                                                                                                                                                                                                                                |
| CONNECT  | This method is used to establish a tunnel to the server. It is rarely used in practice.                                                                                                                                                                                                                                                                                                                                                                                            |
```

-----------------------------------------------------------------
### Generators 
  
Generators in Python are a type of iterable, like lists or tuples. But unlike lists, which store all the elements in memory, generators produce elements on-the-fly, one at a time, and only when requested. This makes them memory-efficient and ideal for working with large datasets or infinite sequences.

Generators are defined using functions that contain the yield keyword. When a generator function is called, it returns a generator object, which can be iterated over using a loop or consumed using the next() function.

Here's an example of a simple generator function that generates the first n Fibonacci numbers:

```python

def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# Create a generator object that generates the first 10 Fibonacci numbers
fibonacci_gen = fibonacci(10)

# Iterate over the generator object and print each Fibonacci number
for fib in fibonacci_gen:
    print(fib)

```

In this example, the fibonacci() function is a generator function that yields Fibonacci numbers one at a time. When called with an argument n, it returns a generator object that can be iterated over to produce the first n Fibonacci numbers.

The yield keyword is used to pause the execution of the generator function and return a value to the caller. The generator function resumes execution from where it left off the next time next() is called on the generator object.

Generators are particularly useful when working with large datasets or infinite sequences, as they allow you to process elements one at a time without having to store them all in memory. They are also useful for writing concise and readable code, as they can be used in place of more complex data structures and algorithms.


### Benefits of Generators in Python

Generators in Python offer several benefits:

1. **Memory Efficiency**: Generators produce elements on-the-fly, one at a time, and only when requested. This means that they don't store all the elements in memory at once, making them memory-efficient. This is particularly useful when working with large datasets or infinite sequences, as it allows you to process elements one at a time without having to store them all in memory.

2. **Lazy Evaluation**: Generators use lazy evaluation, which means that they only evaluate the next element in the sequence when it is requested. This allows for efficient iteration over large datasets or infinite sequences, as it avoids the need to precompute and store all the elements in memory.

3. **Conciseness**: Generators allow for concise and readable code, as they can be used in place of more complex data structures and algorithms. For example, you can use a generator to generate an infinite sequence of Fibonacci numbers in just a few lines of code.

4. **Pipelining**: Generators can be used to create pipelines of data processing steps, where each step consumes data from the previous step and produces data for the next step. This allows for efficient and modular data processing, as each step can be implemented as a separate generator function.

5. **Stateful Iteration**: Generators can maintain state between iterations, which allows for stateful iteration over sequences. This is useful for implementing algorithms that require maintaining state, such as parsing or searching algorithms.

6. **Asynchronous Programming**: Generators can be used to implement asynchronous programming patterns, such as coroutines and async generators. This allows for efficient and scalable asynchronous programming, as it allows for cooperative multitasking and non-blocking I/O.

Overall, generators in Python offer a powerful and flexible way to work with sequences of data, making them a valuable tool for a wide range of applications.


-----------------------------------------------------------------
### Function Caching 
  
Function caching in Python can be achieved using the built-in functools module, specifically the lru_cache decorator. This decorator caches the results of a function with a given set of arguments, which can significantly improve the performance of functions that are called multiple times with the same arguments.

Here's an example of how to use the lru_cache decorator in Python:

```python

from functools import lru_cache

# Define a function to calculate Fibonacci numbers
@lru_cache(maxsize=None)
def fibonacci(n):
    if n <= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)

# Call the fibonacci function multiple times with the same arguments
print(fibonacci(10)) # 55
print(fibonacci(10)) # 55 (cached result)
print(fibonacci(10)) # 55 (cached result)

```

In this example, the fibonacci function is decorated with lru_cache, which means that the results of the function will be cached for the lifetime of the Python process. When the function is called with the same arguments, the cached result will be returned instead of recalculating the result.

You can also control the size of the cache using the maxsize parameter. For example, setting maxsize=128 will limit the cache to 128 entries, and setting maxsize=None (the default) will create an unbounded cache.

Function caching is particularly useful for functions that are computationally expensive or have side effects, as it can reduce the number of times the function needs to be called and improve the overall performance of the program.


-----------------------------------------------------------------
### Regular Expressions
  
Regular expressions, also known as regex, are a powerful tool for pattern matching and text manipulation. They allow you to search for and extract specific patterns of characters from a string.

In Python, the re module provides support for regular expressions. Here's a simple example of how you can use regular expressions in Python:

```python

import re

# Define a regular expression pattern
pattern = r'\bcat\b'

# Create a string to search
text = 'The cat sat on the mat.'

# Use the re.search() function to find the first match
match = re.search(pattern, text)

# If a match is found, print the match
if match:
    print('Found:', match.group())
else:
    print('No match found.')

```

In this example, the regular expression pattern \bcat\b is used to match the word "cat" with word boundaries on both sides, meaning it won't match "cats" or "category", only "cat". The re.search() function is then used to find the first match of the pattern in the given text. If a match is found, match.group() returns the matched text, which is then printed.

Here are some common functions in the `re` module:

- `re.search(pattern, string)`: Searches for the first occurrence of the pattern in the string and returns a `Match` object if found, `None` otherwise.
- `re.match(pattern, string)`: Similar to `re.search()`, but only matches the pattern at the beginning of the string.
- `re.findall(pattern, string)`: Returns a list of all non-overlapping matches of the pattern in the string.
- `re.finditer(pattern, string)`: Returns an iterator of `Match` objects for all non-overlapping matches of the pattern in the string.
- `re.sub(pattern, repl, string)`: Replaces all occurrences of the pattern in the string with the replacement string `repl`.

The `re` module also supports many different metacharacters, which have special meanings in regular expressions. Some common metacharacters include:

- `.`: Matches any single character except newline characters.
- `^`: Matches the start of the string.
- `$`: Matches the end of the string.
- `*`: Matches zero or more occurrences of the preceding character.
- `+`: Matches one or more occurrences of the preceding character.
- `?`: Matches zero or one occurrence of the preceding character.
- `[]`: Matches any single character in the specified set of characters.
- `()`: Groups subpatterns together.
- `|`: Matches either the pattern on the left or the pattern on the right.

For more information on regular expressions in Python, you can refer to the official documentation: [https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html).


-----------------------------------------------------------------
### Beautiful Soup (often abbreviated as bs4) is a Python -- TODO
  
Beautiful Soup (often abbreviated as bs4) is a Python library used for parsing HTML and XML documents. It provides a simple way to navigate and manipulate the parsed data, making it easy to extract information from web pages or XML files.

To use bs4 in Python, you first need to install it using pip. You can do this by running the following command in your terminal or command prompt:

```python



```

-----------------------------------------------------------------
### Creating command line utility in python --TODO
  
**argparse**  
Creating a command-line utility in Python can be achieved using the argparse module, which makes it easy to write user-friendly command-line interfaces. Below is an example of a simple Python script that creates a command-line utility using argparse:
  
  
```python



```

-----------------------------------------------------------------
### AsyncIO
  
AsyncIO is a Python library that provides support for asynchronous I/O operations. It allows you to write concurrent code that can handle many I/O-bound tasks (such as network requests or file operations) without getting blocked by waiting for I/O operations to complete.

AsyncIO is built around the async and await keywords, which allow you to define asynchronous functions and await the results of asynchronous operations. Here's an example of how you can use AsyncIO in Python:

```python
import asyncio

# Define an asynchronous function that simulates a network request
async def fetch_data(url):
    print(f'Starting network request for {url}')
    await asyncio.sleep(2)  # Simulate a 2-second network delay
    print(f'Network request for {url} complete')
    return f'Data from {url}'

# Define an asynchronous function that fetches data from multiple URLs concurrently
async def fetch_all_data():
    urls = ['https://example.com', 'https://example.org', 'https://example.net']
    tasks = [fetch_data(url) for url in urls]
    results = await asyncio.gather(*tasks)
    print('All network requests complete')
    return results

# Run the fetch_all_data function in an event loop
async def main():
    results = await fetch_all_data()
    print('Results:', results)

asyncio.run(main())

```
In this example:

- We define an asynchronous function `fetch_data` that simulates a network request by sleeping for 2 seconds and then returning some data.
- We define an asynchronous function `fetch_all_data` that fetches data from multiple URLs concurrently using `asyncio.gather`.
- We define an asynchronous function `main` that runs the `fetch_all_data` function in an event loop using `asyncio.run`.
- We call the `main` function to start the event loop and run the asynchronous code.

AsyncIO provides a powerful and flexible way to write concurrent code in Python. It is particularly useful for I/O-bound tasks, such as network requests or file operations, where the performance benefits of concurrency can be significant.



asyncio.gather() is a function in the asyncio module of Python that allows you to concurrently execute multiple coroutines (asynchronous functions) and gather their results. It is particularly useful when you have multiple asynchronous tasks that you want to run concurrently, and you want to collect the results of all the tasks once they are complete.

Here's a brief overview of how asyncio.gather() works:

- Define Coroutines: First, you define your coroutines (asynchronous functions) that you want to run concurrently. These coroutines can perform any asynchronous operations, such as network requests or file I/O.

- Call asyncio.gather(): Once you have defined your coroutines, you call asyncio.gather() with the coroutines as arguments. This creates a "future" object that represents the result of the concurrent execution of the coroutines.

- Await the Future Object: You can then await the future object returned by asyncio.gather() to get the results of the coroutines. When all the coroutines have completed, the future object will resolve to a list of their results.


if method is declared as async it should be called as await otherwise will throw error: coroutine 'main' was never awaited

```python
import asyncio
import time

async def func1():
    time.sleep(3)
    print("Task 1 completed")
    return "111"

async def func2():
    time.sleep(1)
    print("Task 2 completed")
    return "222"

async def func3():
    time.sleep(2)
    print("Task 3 completed")   
    return "333"

async def main():
    task1 = await func1()
    await func2()
    await func3()

	
### task1 = asyncio.create_task(func1()) it will call method asynchronously

### following will call all and wait all to complete
# async def main():
    # waitall = await asyncio.gather(func1(),func2(),func3())
    # print(waitall)
	
asyncio.run(main())

```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
