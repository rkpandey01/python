
-----------------------------------------------------------------
## Python
Python console 
-- REPL  REPL stands for Read-Eval-Print Loop. It's an interactive programming environment that reads input from the user, evaluates it, and then prints the result back to the user. Python comes with its own REPL, called the Python interpreter or the Python shell.  

-- IDLE
to exit --- exit()


-----------------------------------------------------------------
###  pep8 recommendations


Here are some of the key recommendations from PEP 8:

Naming Conventions: Use lowercase for variables, UPPERCASE for constants, CamelCase for class names, and snake_case for function names.

Indentation: Use 4 spaces for indentation, and never use tabs.

Whitespace: Use a single space after commas, colons, and semicolons, but no space before them. Use a single space before and after binary operators.

Comments: Use comments to explain the "why" behind your code, not the "what." Write clear and descriptive comments that explain the intent of the code.

Line Length: Limit lines to a maximum of 79 characters.

Imports: Import modules at the top of the file, and group them in the following order: standard library modules, third-party modules, and your own modules.

Blank Lines: Use blank lines to separate logical sections of your code, but don't use them excessively.

Whitespace in Expressions and Statements: Use a single space around assignment operators (=), comparisons (==, <, >, <=, >=, !=, in, not in, is, is not), and arithmetic operators (+, -, *, /, //, %, **).

Documentation Strings (Docstrings): Use triple quotes for multi-line docstrings, and single quotes for single-line docstrings.

Function and Method Arguments: Put a space after the comma in function and method arguments.

Class Definitions: Put a single space after the colon in class definitions.

File Encoding: Use UTF-8 as the default file encoding.

Magic Comments: Use magic comments (# type: ignore) sparingly, and only when necessary.

Exceptions: Use a single space after the except keyword.

Return Statements: Put a space after the return keyword.

Whitespace Around Keywords: Put a single space after keywords like if, elif, else, for, while, except, finally, and with.

Trailing Whitespace: Avoid trailing whitespace at the end of lines.

PEP 8 is not a strict set of rules, and it's not mandatory to follow it. However, adhering to PEP 8 can make your code more readable and maintainable, and it can help you avoid common pitfalls and bugs.

-----------------------------------------------------------------
###  pip

pip is a package manager for Python that allows you to install and manage Python packages. It is the standard package manager for Python and is used to install packages from the Python Package Index (PyPI) or from other sources.

in cmd --->
pip install package-name  
pip uninstall package-name  
pip list  
pip search package-name  
pip show package-name  
pip install --upgrade package-name  
pip install -r requirements.txt  
pip freeze > requirements.txt  
pip install package-name==version  

update pip  
python.exe -m pip install --upgrade pip

-----------------------------------------------------------------
### comments
single line  --- #  
multi --- '''

escape sequence char -- backslash
\"  

```python
print("Hi",2,3,4) # Hi 2 3 4 
print("Hi",2,3,4,sep="#") # Hi#2#3#4 
print("Hi",2,3,4," ",sep="#",end="bye") #Hi#2#3#4# bye  
```

-----------------------------------------------------------------
### python automaticaly assigns datatype
get type -- type(<name>)  
complex(1,2) -- for complex numbers  
in Python all is an objects  

-----------------------------------------------------------------
### list types  
[] -- for list  
() -- tuple -- immutable list  
{} -- dictionary1 = {"key1" : value1, "key2" : value2, "key3" : value3,}  

-----------------------------------------------------------------
### floor division //
```python
print(22/7) # 3.142857142857143
print(22//7) # 3 -- floored value

# exponential **
print(3**3) #27 

```

-----------------------------------------------------------------
### type casting 
```python
int()
str()
float()
bool()
list()
tuple()
set()
dict()
```

-----------------------------------------------------------------
### Get input from the screen
To get user input

```python
input() #always takes as string 
```

-----------------------------------------------------------------
### String 1

stings are imutable 
if saying str.upper() -- it creates a new string 
  
```python

name = "John Doe"
print(f"My name is {name}.")  # Output: "My name is John Doe."

word = "Hello World"
print(len(word)) # Output: 11
print(word[6]) # Output: W
print(word[0:5]) # Output: Hello
print(word[:5]) # Output: Hello
print(word[:]) # Output: Hello World
print(word[0:-3]) # print(word[0:len(word)-3]) # Output: Hello Wo
print(word[-3:-1])  # Output: rl
print(word[-1:-3]) # RHS>LHS # incorrect will print nothing # Output: print nothing
```

f-string --> are placeholders that will be replaced by the actual values of key and value during string formatting.  
This allows you to easily insert variables and expressions into strings without needing to use string concatenation or the .format() method.

-----------------------------------------------------------------
### String 2
  
  
```python

str.rstrip("!") #removes all char ! from the end
str.capitalize() #first letter as capital
str.split(" ") #splits with space and returns list
str.count("Hi") #retruns count of all occurence Hi in string 

string.endswith(suffix[, start[, end]])
string = "Hello, World!"
print(string.endswith("World!"))  # Output: True
print(string.endswith("world!"))  # Output: False (case-sensitive)
print(string.endswith("World", 0, 5))  # Output: False (search only in the first 5 characters)

string.find("is") #returns index of first occurence of is else -1

string.index("is") #throws error if is not found 
string.isalpha()
string.isalnum()
string.islower()
string.isupper()
string.isspace() #checks whitespaces 
string.swapcase()
string.title() # changes first letter of all words in uppercase

```

-----------------------------------------------------------------
### Datetime
  
  
```python
from datetime import datetime

# Create a datetime object representing the current date and time
now = datetime.now()

# Format the date and time using strftime()
formatted_date = now.strftime("%Y-%m-%d %H:%M:%S")
print(formatted_date)  # Output: "2022-02-28 13:45:00"

```

-----------------------------------------------------------------
### If Else
  
```python
x = 10

if x > 5:
    print("x is greater than 5")
elif x < 5:
    print("x is less than 5")
else:
    print("x is equal to 5")



#result = value_if_true if condition else value_if_false

x = 10
result = "Even" if x % 2 == 0 else "Odd"
print(result)  # Output: Even

x = 10
y = 20
result = (x + y) if x > y else (x - y)
print(result)  # Output: -10


```

-----------------------------------------------------------------
### Match case -- Python doesn't have a built-in switch statement  
available in py>3.10  
here break is not required 
  
```python
parameter = "Geeksforgeeks"

match parameter:

	case first : 
		do_something(first)
	
	case second : 
		do_something(second)
		
	case third : 
		do_something(third)
		.............
		............
	case n :
		do_something(n)
	case _ :  # Default
		nothing_matched_function()
		
```
-----------------------------------------------------------------
### comparison operators  

is: The is operator compares the identity of two objects, meaning it checks if the two objects refer to the same memory location. It returns True if the objects are the same, and False otherwise. 
  
==: The == operator compares the values of two objects, meaning it checks if the values of the two objects are the same. It returns True if the values are the same, and False otherwise.

```python
a = [1, 2, 3]
b = [1, 2, 3]
c = a

print(a is b)  # Output: False
print(a is c)  # Output: True

print(a == b)  # Output: True

```

-----------------------------------------------------------------
### Enum
  
  
```python

import enum

class Color(enum.Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

print(Color.RED)    # Output: Color.RED
print(Color.RED.value)  # Output: 1

#You can also use the auto() function from the enum module to automatically assign unique integer values to the members:

import enum

class Color(enum.Enum):
    RED = enum.auto()
    GREEN = enum.auto()
    BLUE = enum.auto()

print(Color.RED)    # Output: Color.RED
print(Color.RED.value)  # Output: 1

#Enumerations can also have string values:
import enum

class Color(enum.Enum):
    RED = 'red'
    GREEN = 'green'
    BLUE = 'blue'

print(Color.RED)    # Output: Color.RED
print(Color.RED.value)  # Output: 'red'


print(Color.RED == Color.RED)    # Output: True
print(Color.RED == Color.GREEN)  # Output: False
print(Color.RED is Color.RED)    # Output: True
print(Color.RED is Color.GREEN)  # Output: False

```

-----------------------------------------------------------------
### For
  
  
```python
# Define a tuple of names
names = ("John Doe", "Jane Doe", "Alice Smith", "Bob Johnson")

# Iterate over the tuple of names and print each name
for name in names:
    print(name)

for i in range(1,100):
    print(i)


# Iterate over a range of numbers from 0 to 10 with a step size of 2
for i in range(0, 11, 2):
    print(i)

```

-----------------------------------------------------------------
### While
    
```python
i = 0

while i < 5:
    print(i)
    i += 1

```
Python doesn't have a built-in do-while loop  

-----------------------------------------------------------------
### Break Continue
  
```python
for i in range(5):
    if i == 3:
        break #breaks the loop and will not exe further 
    print(i)

0
1
2

for i in range(5):
    if i == 3:   #skips the Iteration and will not print 3 but doesn't break 
        continue
    print(i)

0
1
2
4

```

-----------------------------------------------------------------
### Function
    
```python

# ex 1
def add_numbers(a, b):
    return a + b

result = add_numbers(5, 3)
print(result)  # Output: 8

# ex 2 defaults
def avg_digit(a=4,b=6):
    return (a + b)/2

print(avg_digit()) # take defaults for a and b
print(avg_digit(20)) # take defaults for b
print(avg_digit(b=30)) # take defaults for a
print(avg_digit(b=30, a=30)) # order does not matter if added parama name
print(avg_digit(20,30))

# ex 3 dictionary
def avg_sal(d):
    sum = 0 
    for key, value in d.items():
        sum = sum + value 
    print("Average is: " , sum/len(d))


my_dict = {'ram': 10000, 'shayam': 30000, 'mohan': 50000}
avg_sal(my_dict)


# ex 4 list as *

def avg_digit(*nums):
    print(type(nums)) # it will consider passed num list as tuple 
    sum = 0 
    for i in nums:
        sum = sum + i 

    print("Average is: " , sum/len(nums))

avg_digit(2,4,5,6)
list1 = [2,4,6,8,4,6]
avg_digit(*list1 ) # passing list 


# ex 5 dict as **

def avg_sal(**d):
    sum = 0 
    for key, value in d.items():
         print(f'{key}: {value}')
         sum = sum + value 
    print("Average is: " , sum/len(d))

my_dict = {'ram': 10000, 'shayam': 30000, 'mohan': 50000}
avg_sal(**my_dict)

```

the * and ** operators are used for unpacking iterables and dictionaries, respectively. They can be used in function calls to unpack arguments or keyword arguments.  

-----------------------------------------------------------------
### Range
  
  In Python, range() is a built-in function that generates a sequence of numbers. It is commonly used in for loops to iterate over a sequence of numbers. The range() function can take one, two, or three arguments:  
  
One argument: range(stop)

This creates a sequence from 0 up to (but not including) stop.
Example: range(5) generates a sequence from 0 to 4.
Two arguments: range(start, stop)

This creates a sequence from start up to (but not including) stop.
Example: range(2, 5) generates a sequence from 2 to 4.
Three arguments: range(start, stop, step)

This creates a sequence from start up to (but not including) stop, with a step size of step.
Example: range(1, 10, 2) generates a sequence from 1 to 9, with a step size of 2.
  
```python
for i in range(5):
    print(i)

for i in range(2, 5):
    print(i)

for i in range(1, 10, 2):
    print(i)

numbers = list(range(5))
print(numbers)

for i in range(10, 0, -1):
    print(i)

```

-----------------------------------------------------------------
### List
  
  
```python

empty_list = []
print(empty_list)

numbers = [1, 2, 3, 4, 5]
print(numbers)

fruits = ["apple", "banana", "cherry"]
print(fruits)

mixed_list = [1, "apple", 3.14, True]
print(mixed_list)


nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(nested_list)

number_range = list(range(1, 6))
print(number_range)

squares = [x**2 for x in range(1, 6)] # list comprehension 
print(squares)
# output [1, 4, 9, 16, 25]

```

-----------------------------------------------------------------
### List comprehensions
  
  list comprehensions provide a concise way to create lists. They are a syntactic construct that allows you to create a list based on existing lists, iterables, or other data structures.  
[expression for item in iterable if condition]
  
```python

# Using a for loop
squares1 = []
for i in range(10):
    squares1.append(i**2)
    
print(squares1)

# Using a list comprehension
squares2 = [i**2 for i in range(10)]
print(squares2)

#[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# Using a for loop
even_squares1 = []
for i in range(10):
    if i % 2 == 0:
        even_squares1.append(i**2)
print(even_squares1)

# Using a list comprehension
even_squares2 = [i**2 for i in range(10) if i % 2 == 0]
print(even_squares2)

#[0, 4, 16, 36, 64]

# nested list 
# Using a for loop
pairs1 = []
for x in range(3):
    for y in range(3):
        pairs1.append((x, y))
print(pairs1)

# Using a list comprehension
pairs2 = [(x, y) for x in range(3) for y in range(3)]
print(pairs2)

#[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]

```

-----------------------------------------------------------------
### List Methods
  
  
```python

my_list = [1, 2, 3, 4, 5]
print(my_list[0])  # Output: 1

my_list[0] = 9
print(my_list)  # Output: [9, 2, 3, 4, 5]

my_list.append(6)
print(my_list)  # Output: [9, 2, 3, 4, 5, 6]

my_list.insert(2, 7)
print(my_list)  # Output: [9, 2, 7, 3, 4, 5, 6]

my_list.remove(7)
print(my_list)  # Output: [9, 2, 3, 4, 5, 6]

popped_item = my_list.pop()
print(popped_item)  # Output: 6
print(my_list)  # Output: [9, 2, 3, 4, 5]

# # Example 1: Removing and returning the last element
# my_list = [1, 2, 3, 4, 5]
# last_element = my_list.pop()
# print(last_element)  # Output: 5
# print(my_list)  # Output: [1, 2, 3, 4]

# # Example 2: Removing and returning the first element
# first_element = my_list.pop(0)
# print(first_element)  # Output: 1
# print(my_list)  # Output: [2, 3, 4]

# # Example 3: Removing and returning an element at a specific index
# third_element = my_list.pop(1)
# print(third_element)  # Output: 3
# print(my_list)  # Output: [2, 4]


sliced_list = my_list[1:4]
print(sliced_list)  # Output: [2, 3, 4]

my_list.reverse()
print(my_list)  # Output: [5, 4, 3, 2, 9]

my_list.sort()
print(my_list)  # Output: [2, 3, 4, 5, 9]

squared_numbers = [x**2 for x in range(1, 6)]
print(squared_numbers)  # Output: [1, 4, 9, 16, 25]

copied_list = my_list.copy()
print(copied_list)  # Output: [2, 3, 4, 5, 9]

print(7 in my_list)  # Output: False

another_list = [7, 8, 9]
concatenated_list = my_list + another_list
print(concatenated_list)  # Output: [2, 3, 4, 5, 9, 7, 8, 9]

print(my_list.count(3))  # Output: 1

print(len(my_list))  # Output: 5

my_list.clear()
print(my_list)  # Output: []



```
.pop() method in Python is a list method that removes and returns the last element from the list.  
It modifies the original list in place. If you specify an index, it will remove and return the element at that index.  
If you do not specify an index, it will remove and return the last element in the list.

-----------------------------------------------------------------
### Two List Methods
  
  
```python

# Define two lists
list1 = [1, 2, 3, 4, 5]
list2 = [4, 5, 6, 7, 8]

# Appending list1 to list2
list2.extend(list1)
print(list2)  # Output: [4, 5, 6, 7, 8, 1, 2, 3, 4, 5]

# Removing duplicates from the combined list
list2 = list(set(list2))
print(list2)  # Output: [1, 2, 3, 4, 5, 6, 7, 8]

# Sorting the combined list in descending order
list2.sort(reverse=True)
print(list2)  # Output: [8, 7, 6, 5, 4, 3, 2, 1]

#Union of two lists (combining unique elements from both lists):

list1 = [1, 2, 3]
list2 = [3, 4, 5]

union_list = list(set(list1) | set(list2))
print(union_list)  # Output: [1, 2, 3, 4, 5]

#Difference between two lists (elements that are in list1 but not in list2):
list1 = [1, 2, 3, 4, 5]
list2 = [3, 4, 5, 6, 7]

difference_list = list(set(list1) - set(list2))
print(difference_list)  # Output: [1, 2]

#Symmetric difference between two lists (elements that are in either list1 or list2, but not in both):
list1 = [1, 2, 3, 4, 5]
list2 = [3, 4, 5, 6, 7]

symmetric_difference_list = list(set(list1) ^ set(list2))
print(symmetric_difference_list)  # Output: [1, 2, 6, 7]

#Concatenating two lists (combining elements from both lists):
list1 = [1, 2, 3]
list2 = [4, 5, 6]

concatenated_list = list1 + list2
print(concatenated_list)  # Output: [1, 2, 3, 4, 5, 6]

#Merging two lists (combining elements from both lists without duplicates):
list1 = [1, 2, 3]
list2 = [3, 4, 5]

merged_list = list(set(list1) | set(list2))
print(merged_list)  # Output: [1, 2, 3, 4, 5]

#Intersection of two lists (elements that are common in both lists):
list1 = [1, 2, 3]
list2 = [3, 4, 5]

intersection_list = list(set(list1) & set(list2))
print(intersection_list)  # Output: [3]

#Checking if all elements of one list are present in another list:
list1 = [1, 2, 3]
list2 = [1, 2, 3, 4, 5]

is_subset = all(elem in list2 for elem in list1)
print(is_subset)  # Output: True


```

-----------------------------------------------------------------
### Tuples 
A tuple is an immutable data type, meaning that once it is created, its elements cannot be changed or modified. Tuples are similar to lists, but they are enclosed in parentheses () instead of square brackets [].  
In Python, a tuple is a collection of elements, which can be of any data type, including characters. A tuple can contain duplicate elements, including duplicate characters.
Tuples can contain elements of different types, and they can be indexed and sliced in the same way as lists. 

```python
#Creating a Tuple with One Element:

my_tuple = (1,) #single ele tuple -- add , in the last otherwise considered as int 

single_element_tuple = tuple([1])
print(single_element_tuple)  # Output: (1,)

multiple_elements_tuple = tuple([1, 2, 3])
print(multiple_elements_tuple)  # Output: (1, 2, 3)

my_tuple = ('a', 'b', 'c', 'a', 'd', 'e', 'a')
print(my_tuple.count('a'))  # Output: 3


my_tuple = (1, 2, 3, 4, 5)

#Repeating a Tuple:
repeated_tuple = my_tuple * 2
print(repeated_tuple)  # Output: (1, 2, 3, 4, 5, 1, 2, 3, 4, 5)

#Unpacking a Tuple:
a, b, c, d, e = my_tuple
print(a, b, c, d, e)  # Output: 1 2 3 4 5

#Converting a List to a Tuple:
my_list = [1, 2, 3, 4, 5]
tuple_from_list = tuple(my_list)
print(tuple_from_list)  # Output: (1, 2, 3, 4, 5)

#Checking if Two Tuples are Equal:
tuple1 = (1, 2, 3)
tuple2 = (1, 2, 3)
print(tuple1 == tuple2)  # Output: True

#Converting a List of Tuples to a Dictionary:
list_of_tuples = [(1, 'a'), (2, 'b'), (3, 'c')]
dictionary_from_list = dict(list_of_tuples)
print(dictionary_from_list)  # Output: {1: 'a', 2: 'b', 3: 'c'}


#Counting the Occurrences of an Element in a Tuple:
my_tuple = (1, 2, 3, 4, 5, 3, 3)
count_of_3 = my_tuple.count(3)
print(count_of_3)  # Output: 3

#Reversing a Tuple:
my_tuple = (1, 2, 3, 4, 5)
reversed_tuple = my_tuple[::-1]
print(reversed_tuple)  # Output: (5, 4, 3, 2, 1)

#Sorting a Tuple:
my_tuple = (4, 2, 1, 3, 5)
sorted_tuple = tuple(sorted(my_tuple))
print(sorted_tuple)  # Output: (1, 2, 3, 4, 5)

#Checking if a Tuple is Empty:
empty_tuple = ()
is_empty = not bool(empty_tuple)
print(is_empty)  # Output: True


#Splitting Tuples:
my_tuple = (1, 2, 3, 4, 5, 6)
split_tuple1 = my_tuple[:3]
split_tuple2 = my_tuple[3:]
print(split_tuple1)  # Output: (1, 2, 3)
print(split_tuple2)  # Output: (4, 5, 6)

#Checking if Two Tuples Overlap:
tuple1 = (1, 2, 3, 4)
tuple2 = (3, 4, 5, 6)
overlap = bool(set(tuple1) & set(tuple2))
print(overlap)  # Output: True

#Creating a Tuple with Named Elements Using NamedTuple:
from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
point = Point(1, 2)
print(point.x, point.y)  # Output: 1 2

#Creating a Tuple from a String:
string = "hello"
tuple_from_string = tuple(string)
print(tuple_from_string)  # Output: ('h', 'e', 'l', 'l', 'o')

#Checking if a Tuple Contains Only Unique Elements:
unique_tuple = (1, 2, 3, 4, 5)
is_unique = len(unique_tuple) == len(set(unique_tuple))
print(is_unique)  # Output: True


```

-----------------------------------------------------------------
### Swapping Values Between Variables Using Tuples:
  
```python
a = 1
b = 2
a, b = b, a
print(a, b)  # Output: 2 1

```

-----------------------------------------------------------------
### Build-in methods
  
  
```python

Tuples have many built-in functions and methods that are similar to those of lists in Python. Here are some common functions and methods that can be used with tuples:

len(): Returns the number of elements in the tuple.

tuple(): Converts a sequence into a tuple.

sorted(): Returns a new sorted list of the elements in the tuple.

max(): Returns the largest element in the tuple.

min(): Returns the smallest element in the tuple.

sum(): Returns the sum of all elements in the tuple.

count(): Returns the number of occurrences of a specified value in the tuple.

index(): Returns the index of the first occurrence of a specified value in the tuple.

+: Concatenates two tuples and returns a new tuple.

*: Repeats the elements of the tuple a specified number of times and returns a new tuple.

in: Checks if a specified value is present in the tuple.

not in: Checks if a specified value is not present in the tuple.

==: Compares two tuples for equality.

!=: Compares two tuples for inequality.

<: Checks if the first tuple is less than the second tuple.

<=: Checks if the first tuple is less than or equal to the second tuple.

>: Checks if the first tuple is greater than the second tuple.

>=: Checks if the first tuple is greater than or equal to the second tuple.

del: Deletes the entire tuple.

enumerate(): Returns an enumerate object that contains tuples of the index and value of each element in the tuple.

filter(): Returns an iterator that contains the elements from the tuple for which the specified function returns True.

map(): Returns an iterator that contains the results of applying the specified function to each element in the tuple.

reversed(): Returns a reverse iterator that contains the elements of the tuple in reverse order.

slice(): Returns a slice object that represents the specified range of elements in the tuple.

sorted(): Returns a new sorted list of the elements in the tuple.

zip(): Returns an iterator that combines the elements of the tuple with the elements of one or more other iterables.

```

-----------------------------------------------------------------
### Docstrings 
  
In Python, a docstring is a string literal that is used to document a function, method, class, or module. It is placed as the first statement in the body of the function, method, class, or module, and is enclosed in triple quotes (''' or """). Docstrings are used to provide documentation about the purpose, usage, and behavior of the code, and can be accessed using the .__doc__ attribute of the object.
  
```python

def add(a, b):
    '''This function takes two numbers as input and returns their sum.'''
    return a + b

print(add.__doc__)

#docstring for a class:
class Point:
    '''This class represents a point in 2D space.'''
    def __init__(self, x, y):
        '''Constructor for the Point class.'''
        self.x = x
        self.y = y

```

-----------------------------------------------------------------
### Recursion 
  
  
```python

def fact(n):
    if n==0 or n==1:
        return 1
    else:
        return n * fact(n-1)
    
print(fact(5))


def fibbo(n):
    if n <= 1:
        return n
    else:
        return fibbo(n - 1) + fibbo(n - 2)

fi = fibbo(10)
print(fi)


```

-----------------------------------------------------------------
### Sets 
  
In Python, a set is an *unordered* collection of unique elements. Sets are mutable, which means that you can add or remove elements from a set after it has been created. Sets are implemented using a hash table, which allows for fast lookup and insertion of elements.

```python

# Create an empty set
empty_set = set()

# Create a set with elements
my_set = {1, 2, 3, 4, 5}

# Add elements to a set
my_set.add(6)
my_set.add(7)

# Remove an element from a set
my_set.remove(3)


set1 = {1, 2, 3}
set2 = {1, 2, 3, 4, 5}
print(set1.issubset(set2))  # Output: True

set1 = {1, 2, 3, 4, 5}
set2 = {1, 2, 3}
print(set1.issuperset(set2))  # Output: True


#isdisjoint() Method: Returns True if the two sets have no common elements, otherwise False.
set1 = {1, 2, 3}
set2 = {4, 5, 6}
print(set1.isdisjoint(set2))  # Output: True

#difference() Method: Returns a new set with elements that are in the original set but not in the specified set.
set1 = {1, 2, 3}
set2 = {3, 4, 5}
difference_set = set1.difference(set2)
print(difference_set)  # Output: {1, 2}


# Create two sets
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

# Union of sets
union = set1.union(set2)  # Output: {1, 2, 3, 4, 5, 6, 7, 8}

# Intersection of sets
intersection = set1.intersection(set2)  # Output: {4, 5}

# Difference of sets
difference = set1.difference(set2)  # Output: {1, 2, 3}

# Symmetric difference of sets
symmetric_difference = set1.symmetric_difference(set2)  # Output: {1, 2, 3, 6, 7, 8}




```
isdisjoint() Method: Returns True if the two sets have no common elements, otherwise False.  

pop() Method: Removes and returns an arbitrary element from the set. If the set is empty, it raises a KeyError.

remove() Method: Removes the specified element from the set. If the element is not present, it raises a KeyError.

discard() Method: Removes the specified element from the set if it is present. If the element is not present, it doesn't raise an error.

-----------------------------------------------------------------
### Sets update
  
The union() method in Python is used to return a new set containing all the unique elements from both the sets. It creates a new set by combining the elements of the two sets without any repetitions.

The update() method in Python is used to modify a set by adding all the elements from another set or any other iterable object like a list, tuple, or string.

```python

# Create two sets
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

# Union of sets
union_set = set1.union(set2)
print(union_set)  # Output: {1, 2, 3, 4, 5, 6, 7, 8}


# Create a set
my_set = {1, 2, 3, 4, 5}

# Update the set by adding elements from another set
my_set.update({6, 7, 8})
print(my_set)  # Output: {1, 2, 3, 4, 5, 6, 7, 8}

# Update the set by adding elements from a list
my_set.update([9, 10])
print(my_set)  # Output: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

# Update the set by adding elements from a tuple
my_set.update((11, 12))
print(my_set)  # Output: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}

# Update the set by adding characters from a string
my_set.update("hello")
print(my_set)  # Output: {'h', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'l', 'o', 'e'}


set1 = {1, 2, 3}
set2 = {3, 4, 5}
symmetric_difference_set = set1.symmetric_difference(set2)
print(symmetric_difference_set)  # Output: {1, 2, 4, 5}



set1 = {1, 2, 3}
set2 = {3, 4, 5}
set1.update(set2)
print(set1)  # Output: {1, 2, 3, 4, 5}


set1 = {1, 2, 3}
set2 = {3, 4, 5}
set1.difference_update(set2)
print(set1)  # Output: {1, 2}


set1 = {1, 2, 3}
set2 = {3, 4, 5}
set1.intersection_update(set2)
print(set1)  # Output: {3}


set1 = {1, 2, 3}
set2 = {3, 4, 5}
set1.symmetric_difference_update(set2)
print(set1)  # Output: {1, 2, 4, 5}


```
symmetric_difference() Method: Returns a new set with elements that are in either the original set or the specified set, but not in both.  
update() Method: Adds all elements from another set (or any other iterable object) to the original set.  
difference_update() Method: Removes all elements from the original set that are also present in the specified set.  
intersection_update() Method: Removes all elements from the original set that are not present in both sets.  
symmetric_difference_update() Method: Modifies the original set to contain elements that are in either the original set or the specified set, but not in both.  

-----------------------------------------------------------------
### del
  
The del keyword in Python is used to delete objects. It can be used to delete elements from lists, elements from dictionaries, attributes from objects, and objects themselves.

```python

my_list = [1, 2, 3, 4, 5]
del my_list[2]  # Deletes the element at index 2
print(my_list)  # Output: [1, 2, 4, 5]

del my_list  # Deletes the object
print(my_list)  # Output: NameError: name 'my_list' is not defined


class MyClass:
    def __init__(self, x):
        self.x = x

obj = MyClass(5)
del obj.x  # Deletes the attribute 'x' from the object
print(obj.x)  # Raises AttributeError: 'MyClass' object has no attribute 'x'


```

-----------------------------------------------------------------
### Dictionaries
  
 dictionary in Python is a data structure that is used to store data in a key-value pair format. Each key in the dictionary must be unique and immutable (such as a string, number, or tuple), and each key is associated with a value. The value can be of any data type, including another dictionary.
 
```python
# Creating a dictionary
my_dict = {
    "name": "John",
    "age": 30,
    "city": "New York"
}

# Accessing values in the dictionary
print(my_dict["name"])  # Output: John
print(my_dict["age"])   # Output: 30
print(my_dict["city"])  # Output: New York

# Adding a new key-value pair to the dictionary
my_dict["country"] = "USA"
print(my_dict["country"])  # Output: USA

# Removing a key-value pair from the dictionary
del my_dict["city"]
print(my_dict)  # Output: {'name': 'John', 'age': 30, 'country': 'USA'}

print(my_dict.get("city"))  # Output: None
print(my_dict["city"])  # Output: Will throw Error

```

-----------------------------------------------------------------
### Dictionary methods
  
  
```python

#clear(): Removes all items from the dictionary.
my_dict = {"name": "John", "age": 30}
my_dict.clear()
print(my_dict)  # Output: {}

#copy(): Returns a shallow copy of the dictionary.
my_dict = {"name": "John", "age": 30}
new_dict = my_dict.copy()
print(new_dict)  # Output: {'name': 'John', 'age': 30}

#get(key[, default]): Returns the value for the specified key. If the key is not found, it returns the default value (which is None by default).
my_dict = {"name": "John", "age": 30}
print(my_dict.get("name"))    # Output: John
print(my_dict.get("country")) # Output: None
print(my_dict.get("country", "USA")) # Output: USA

#items(): Returns a view object that displays a list of a dictionary's key-value pairs as tuples.
my_dict = {"name": "John", "age": 30}
print(my_dict.items()) # Output: dict_items([('name', 'John'), ('age', 30)])

#keys(): Returns a view object that displays a list of a dictionary's keys.
my_dict = {"name": "John", "age": 30}
print(my_dict.keys()) # Output: dict_keys(['name', 'age'])

#values(): Returns a view object that displays a list of a dictionary's values.
my_dict = {"name": "John", "age": 30}
print(my_dict.values()) # Output: dict_values(['John', 30])

#pop(key[, default]): Removes and returns the item with the specified key. If the key is not found, it returns the default value (which is None by default).
my_dict = {"name": "John", "age": 30}
print(my_dict.pop("name"))    # Output: John
print(my_dict.pop("country")) # Output: KeyError: 'country'
print(my_dict.pop("country", "USA")) # Output: USA

#popitem(): Removes and returns an arbitrary (key, value) pair from the dictionary.
my_dict = {"name": "John", "age": 30}
print(my_dict.popitem()) # Output: ('age', 30)
print(my_dict) # Output: {'name': 'John'}

#setdefault(key[, default]): Returns the value of the specified key. If the key does not exist, it inserts the key with the specified default value (which is None by default) and returns the default value.
my_dict = {"name": "John", "age": 30}
print(my_dict.setdefault("name")) # Output: John
print(my_dict.setdefault("country")) # Output: None
print(my_dict) # Output: {'name': 'John', 'age': 30, 'country': None}

#update(iterable): Updates the dictionary with the key-value pairs from the specified iterable.
my_dict = {"name": "John", "age": 30}
my_dict.update({"country": "USA"})
print(my_dict) # Output: {'name': 'John', 'age': 30, 'country': 'USA'}

#fromkeys(iterable[, value]): Returns a new dictionary with keys from the iterable and values set to the specified value (which is None by default).
keys = ["name", "age", "country"]
my_dict = dict.fromkeys(keys)
print(my_dict) # Output: {'name': None, 'age': None, 'country': None}

#len(): Returns the number of items in the dictionary.
my_dict = {"name": "John", "age": 30}
print(len(my_dict)) # Output: 2

```

-----------------------------------------------------------------
### Loop with else
  
In Python, you can use an else block in a for or while loop. The else block is executed when the loop completes normally (without encountering a break statement). 

```python
for i in range(5):
    print(i)
else:
    print("Loop completed normally")

i = 0
while i < 5:
    print(i)
    i += 1
else:
    print("Loop completed normally")


#output
0
1
2
3
4
Loop completed normally



```

-----------------------------------------------------------------
### Exception handling
  
Exception handling in Python is a way to deal with errors or exceptional situations that might occur during the execution of a program. Python provides a try-except-else-finally block for handling exceptions.


```python
try:
    # Code that might raise an exception
    x = 1 / 0
except ZeroDivisionError:
    # Code that handles the exception
    print("Cannot divide by zero")
else:
    # Code that runs if no exception occurs
    print("Division successful")
finally:
    # Code that always runs, regardless of whether an exception occurred
    print("Finally block")

# #Output
# Cannot divide by zero
# Finally block

# You can also use try-except blocks to catch exceptions and then raise a new exception:

try:
    # Code that might raise an exception
    x = 1 / 0
except ZeroDivisionError as e:
    # Code that handles the ZeroDivisionError exception
    print("Cannot divide by zero")
    raise ValueError("Error occurred") from e

# #Output
# Cannot divide by zero
# Traceback (most recent call last):
  # File "<stdin>", line 2, in <module>
# ValueError: Error occurred


#example of a stack trace:
def function_a():
    function_b()

def function_b():
    function_c()

def function_c():
    x = 1 / 0

try:
    function_a()
except ZeroDivisionError as e:
    print(f"An error occurred: {e}")

# #Output
# An error occurred: division by zero
# Traceback (most recent call last):
  # File "<stdin>", line 11, in <module>
  # File "<stdin>", line 2, in function_a
  # File "<stdin>", line 5, in function_b
  # File "<stdin>", line 8, in function_c
# ZeroDivisionError: division by zero

```
### Exception Types in Python

- **Exception**: The base class for all built-in exceptions. It is the parent class for all exceptions in Python.

- **TypeError**: Raised when an operation or function is applied to an object of an inappropriate type.

- **ValueError**: Raised when a built-in operation or function receives an argument that has the right type but an inappropriate value.

- **ZeroDivisionError**: Raised when the second argument of a division or modulo operation is zero.

- **FileNotFoundError**: Raised when a file or directory is requested but cannot be found.

- **IndexError**: Raised when a sequence subscript is out of range.

- **KeyError**: Raised when a dictionary key is not found.

-----------------------------------------------------------------
### Enumerate Function 
  

In Python, the enumerate() function is used to loop over a sequence (such as a list, tuple, or string) while keeping track of the index of each element. It returns an enumerate object, which is an iterator that yields pairs of an index and the corresponding element.

```python

#enumerate(iterable, start=0)

my_list = ['apple', 'banana', 'cherry']
for index, value in enumerate(my_list):
    print(f"Index: {index}, Value: {value}")

# Index: 0, Value: apple
# Index: 1, Value: banana
# Index: 2, Value: cherry

my_list = ['apple', 'banana', 'cherry']
for index, value in enumerate(my_list, start = 1):
    print(f"Index: {index}, Value: {value}")

# It will start index from 1 
# Index: 1, Value: apple
# Index: 2, Value: banana
# Index: 3, Value: cherry


```

-----------------------------------------------------------------
### Virtual Environment in Python --TODO
  
A virtual environment in Python is a self-contained directory that contains a Python installation for a particular version of Python, plus a number of additional packages. This allows you to work on multiple projects with different dependencies without them interfering with each other.
  
A virtual environment in Python is a self-contained directory that contains a Python installation for a particular version of Python, plus a number of additional packages. This allows you to work on multiple projects with different dependencies without them interfering with each other.

Here's how to create and use a virtual environment in Python:

1. **Creating a Virtual Environment**:
    - Open a terminal or command prompt.
    - Navigate to the directory where you want to create the virtual environment.
    - Run the following command to create a virtual environment named `venv`:

        ```
        python -m venv venv
        ```

    - This will create a directory named `venv` in the current directory with a Python installation and a `pip` package manager.

2. **Activating the Virtual Environment**:
    - To activate the virtual environment, run the following command:

        - On Windows:

            ```
            venv\Scripts\activate
            ```

        - On macOS and Linux:

            ```
            source venv/bin/activate
            ```

    - When the virtual environment is activated, your terminal or command prompt prompt will change to indicate that the virtual environment is active.

3. **Using the Virtual Environment**:
    - When the virtual environment is active, any Python commands you run will use the Python installation and packages in the virtual environment.
    - For example, you can install packages using `pip`:

        ```
        pip install package_name
        ```

4. **Deactivating the Virtual Environment**:
    - To deactivate the virtual environment and return to the global Python installation, run the following command:

        ```
        deactivate
        ```

    - After deactivating the virtual environment, your terminal or command prompt prompt will return to its normal state.

5. **Deleting the Virtual Environment**:
    - To delete the virtual environment, simply delete the directory where it is located.

This is a basic overview of virtual environments in Python. They are a powerful tool for managing dependencies and isolating project environments. You can find more information in the [Python documentation](https://docs.python.org/3/library/venv.html).


-----------------------------------------------------------------
### import
  
  
```python

import my_module
my_module.my_function()    

from my_module import my_function
my_function()    

import my_module as mm
mm.my_function()    

#Importing All Attributes from a Module:
from my_module import * 
my_function()   

#Importing a Package:
import my_package
my_package.my_module.my_function()     	


import math
print(dir(math))
print(dir(math.__doc__.__add__))


```

-----------------------------------------------------------------
### if __name__ == "__main__":
  
In Python, the '__name__' variable is a special built-in variable. When a Python script is executed, __name__ is automatically set to "__main__" if the script is the main program being run. If the script is being imported as a module, then __name__ is set to the name of the module.

The if '__name__' == "__main__": construct is often used to create a script that can be both run as a standalone program and imported as a module into another program.

if you are importing the module having methods valls in other module it is required to add this statement to avoid exe of those methods 
```python
#py_math.py
import math as mm

def sqrt(i):
    return mm.sqrt(i)

def justprint():
    print("u r in math.py")

PI = 3.14 

justprint()

#main.py
import py_math
#from py_math import * 

#justprint()
py_math.justprint()

#if u run > python main.py -- it will print 2 times 
# u r in math.py
# u r in math.py

# even adding import py_math -- will call justprint()

```

-----------------------------------------------------------------
### import os 
  
  For Dir and file operations
  
  os.system(cmd) #to run apps
```python



```

-----------------------------------------------------------------
### global
  
  Declaring a variable as global in Python means that the variable will be treated as a global variable within the current module or scope. This means that changes made to the variable in one part of the code will be reflected in other parts of the code as well.
  
```python

py = "This is a global variable"

def my_function():
    global py
    py = "This is a modified global variable"

my_function()
print(py)  # Output: This is a modified global variable


```

-----------------------------------------------------------------
### File Handling 
  
File can't be read in write mode. 
'w' write 
'r' read mode is default  
'rb' read binary

```python
f = open('Sample.txt', 'r')

txt = f.read()
print(txt)
f.close()

#f = open('Sample.txt', 'w') #this write mode will create new file if file is not present

# write 
# Open the file in write mode
with open("Sample.txt", "w") as file:
    # Write content to the file
    file.write("This is a new line of text.\n")
    file.write("This is another line of text.\n")

# Read the file content to verify
with open("Sample.txt", "r") as file:
    file_content = file.read()

# Print the content
print(file_content)

#readlines(): This method reads the entire content of the file and returns a list of strings, where each string is a line from the file.
with open("file.txt", "r") as file:
    lines = file.readlines()
for line in lines:
    print(line.strip())

# Create a list of strings
lines = ["This is line 1.\n", "This is line 2.\n", "This is line 3.\n"]

# Open the file in write mode
with open("file.txt", "w") as file:
    # Write the list of strings to the file
    file.writelines(lines)

# Read the file content to verify
with open("file.txt", "r") as file:
    file_content = file.read()

# Print the content
print(file_content)

with open("file.txt", "r") as file:
    # Move the cursor to the beginning of the file
    file.seek(0)
    # Read the first 10 characters from the file
    content = file.read(10)
    print(content)

with open("file.txt", "r") as file:
    # Read the first 10 characters from the file
    content = file.read(10)
    # Print the current file cursor position
    print(file.tell())

```  

seek(): This function is used to change the file cursor position. It takes two arguments: offset and whence. The offset argument specifies the number of bytes to move the cursor, and the whence argument specifies the reference point for the cursor movement. The whence argument can take one of the following values:

0: The beginning of the file  
1: The current file cursor position (default)  
2: The end of the file  

tell(): This function returns the **current file cursor position** as an integer number of bytes from the beginning of the file.

flush(): This method flushes the internal buffer of the file object, forcing all buffered data to be written to the file.  

close(): This method closes the file object. Once a file is closed, no further read or write operations can be performed on it.

-----------------------------------------------------------------
### truncate()
  
In Python, the truncate() method is used to resize a file to a specified size. It is a method of the file object returned by the open() function when the file is opened in write or read/write mode ("w", "r+", "a", or "a+"). The truncate() method takes an optional size argument that specifies the new size of the file in bytes. If the size argument is omitted or negative, the file is truncated to the current file cursor position.

```python

# Open the file in write mode
with open("file.txt", "w") as file:
    # Write some content to the file
    file.write("This is a line of text.\n")
    file.write("This is another line of text.\n")

# Open the file in read/write mode
with open("file.txt", "r+") as file:
    # Move the cursor to the beginning of the file
    file.seek(0)
    # Read the first line from the file
    content = file.readline()
    # Print the content
    print(content)
    # Truncate the file to the current file cursor position
    file.truncate()
    # Read the first line from the file again
    content = file.readline()
    # Print the content
    print(content)


```

In this example, the file file.txt is opened in write mode, and two lines of text are written to the file. The file is then opened in read/write mode, and the cursor is moved to the beginning of the file. The first line of the file is read and printed, and then the file is truncated to the current file cursor position. This means that the file is resized to the beginning of the file, and all content after the cursor position is removed. Finally, the first line of the file is read and printed again to show that the file has been truncated.


-----------------------------------------------------------------
### Lambda functions
  
 A lambda function in Python is a small anonymous function that can take any number of arguments, but can only have one expression. Lambda functions are often used when you need a simple function for a short period of time. They are defined using the lambda keyword, followed by a comma-separated list of arguments, a colon ( : ), and the expression to be evaluated.
 
 fun_name = lambda (params : action)
 
```python
# Define a lambda function that adds two numbers
add = lambda x, y: x + y

# Call the lambda function with two arguments
result = add(3, 5)
print(result)  # Output: 8
```

passing lambda in function 

```python
# Define a custom function that takes a lambda function as an argument
def apply_function(numbers, func):
    return [func(x) for x in numbers]

# Define a list of numbers
numbers = [1, 2, 3, 4, 5]

# Use a lambda function to square each number
squared_numbers = apply_function(numbers, lambda x: x ** 2)
print(squared_numbers)  # Output: [1, 4, 9, 16, 25]

```

-----------------------------------------------------------------
### Map, Filter and Reduce 
  
In Python, map(), filter(), and reduce() are built-in functions that are commonly used for functional programming tasks. They are often used in conjunction with lambda functions to perform operations on sequences like lists, tuples, and sets.  

Note that in Python 3.x, map() and filter() return iterators instead of lists. You can convert these iterators to lists by wrapping them in a list() function call.  

map(): The map() function takes a function and an iterable (like a list) as arguments and applies the function to each element of the iterable, returning a new iterable with the results.

```python
numbers = [1, 2, 3, 4, 5]
doubled_numbers = map(lambda x: x * 2, numbers)
print(list(doubled_numbers))  # Output: [2, 4, 6, 8, 10]

```

filter(): The filter() function takes a function and an iterable as arguments and applies the function to each element of the iterable, returning a new iterable with only the elements for which the function returns True.

```python

numbers = [1, 2, 3, 4, 5]
even_numbers = filter(lambda x: x % 2 == 0, numbers)
print(list(even_numbers))  # Output: [2, 4]

```

reduce(): The reduce() function is used to apply a function to a sequence of elements and reduce the sequence to a single value. It is part of the functools module in Python 3.x and needs to be imported.

```python
from functools import reduce
numbers = [1, 2, 3, 4, 5]
sum_of_numbers = reduce(lambda x, y: x + y, numbers)
print(sum_of_numbers)  # Output: 15

```
-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
### 
  
  
```python



```

-----------------------------------------------------------------
